<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java集合容器面试题 | Vic&#39;s blog</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/img/favicon.ico">
    <script data-ad-client="ca-pub-7828333725993554" async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="description" content="Talk is cheap. Show me the code.">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    <link rel="preload" href="/assets/css/0.styles.ee07844b.css" as="style"><link rel="preload" href="/assets/js/app.646a5a8b.js" as="script"><link rel="preload" href="/assets/js/2.18e0a64f.js" as="script"><link rel="preload" href="/assets/js/3.cb3603b5.js" as="script"><link rel="preload" href="/assets/js/123.9a3fac58.js" as="script"><link rel="prefetch" href="/assets/js/10.0d9d304b.js"><link rel="prefetch" href="/assets/js/100.b7965827.js"><link rel="prefetch" href="/assets/js/101.ec938c9e.js"><link rel="prefetch" href="/assets/js/102.36158cee.js"><link rel="prefetch" href="/assets/js/103.fc26454f.js"><link rel="prefetch" href="/assets/js/104.8974de3a.js"><link rel="prefetch" href="/assets/js/105.ddc87d30.js"><link rel="prefetch" href="/assets/js/106.377af6a9.js"><link rel="prefetch" href="/assets/js/107.499f211f.js"><link rel="prefetch" href="/assets/js/108.8bf108dd.js"><link rel="prefetch" href="/assets/js/109.8c40dc08.js"><link rel="prefetch" href="/assets/js/11.76a79190.js"><link rel="prefetch" href="/assets/js/110.d700f36a.js"><link rel="prefetch" href="/assets/js/111.44062da2.js"><link rel="prefetch" href="/assets/js/112.9bdeef30.js"><link rel="prefetch" href="/assets/js/113.3c99cc8c.js"><link rel="prefetch" href="/assets/js/114.30279ca5.js"><link rel="prefetch" href="/assets/js/115.ab365d65.js"><link rel="prefetch" href="/assets/js/116.8ea63884.js"><link rel="prefetch" href="/assets/js/117.ec0abe02.js"><link rel="prefetch" href="/assets/js/118.5a00cb6f.js"><link rel="prefetch" href="/assets/js/119.ec09616a.js"><link rel="prefetch" href="/assets/js/12.20f93e21.js"><link rel="prefetch" href="/assets/js/120.e0ec0010.js"><link rel="prefetch" href="/assets/js/121.fa09c331.js"><link rel="prefetch" href="/assets/js/122.d1cf27e3.js"><link rel="prefetch" href="/assets/js/124.08c07432.js"><link rel="prefetch" href="/assets/js/125.6b74abe2.js"><link rel="prefetch" href="/assets/js/126.4a684ea9.js"><link rel="prefetch" href="/assets/js/127.be4f0a2e.js"><link rel="prefetch" href="/assets/js/128.7305eacf.js"><link rel="prefetch" href="/assets/js/129.2c428c83.js"><link rel="prefetch" href="/assets/js/13.5fd8d8bd.js"><link rel="prefetch" href="/assets/js/130.e09f130a.js"><link rel="prefetch" href="/assets/js/131.517c11dd.js"><link rel="prefetch" href="/assets/js/132.38f222f2.js"><link rel="prefetch" href="/assets/js/133.9a20bd52.js"><link rel="prefetch" href="/assets/js/134.329e49a4.js"><link rel="prefetch" href="/assets/js/135.4f758179.js"><link rel="prefetch" href="/assets/js/136.0d8bd029.js"><link rel="prefetch" href="/assets/js/137.8a2e7d65.js"><link rel="prefetch" href="/assets/js/138.2a45e9e8.js"><link rel="prefetch" href="/assets/js/139.c4d29fc3.js"><link rel="prefetch" href="/assets/js/14.6997bc57.js"><link rel="prefetch" href="/assets/js/140.b33ff3d7.js"><link rel="prefetch" href="/assets/js/141.c2c0cdf4.js"><link rel="prefetch" href="/assets/js/142.7434742e.js"><link rel="prefetch" href="/assets/js/143.6dda5ead.js"><link rel="prefetch" href="/assets/js/144.19b2044e.js"><link rel="prefetch" href="/assets/js/145.db9344a5.js"><link rel="prefetch" href="/assets/js/146.09278f85.js"><link rel="prefetch" href="/assets/js/147.b61888d6.js"><link rel="prefetch" href="/assets/js/148.f30409cd.js"><link rel="prefetch" href="/assets/js/149.e19cf9ab.js"><link rel="prefetch" href="/assets/js/15.1ed4f660.js"><link rel="prefetch" href="/assets/js/150.eec3b1ad.js"><link rel="prefetch" href="/assets/js/151.a83ed8e1.js"><link rel="prefetch" href="/assets/js/152.d36fd772.js"><link rel="prefetch" href="/assets/js/153.50f45bcf.js"><link rel="prefetch" href="/assets/js/154.da3ff946.js"><link rel="prefetch" href="/assets/js/155.28093a46.js"><link rel="prefetch" href="/assets/js/156.4b4b9030.js"><link rel="prefetch" href="/assets/js/157.5fccae7f.js"><link rel="prefetch" href="/assets/js/158.cf9f8c15.js"><link rel="prefetch" href="/assets/js/159.93bc7c37.js"><link rel="prefetch" href="/assets/js/16.7a7c6662.js"><link rel="prefetch" href="/assets/js/160.18bc703a.js"><link rel="prefetch" href="/assets/js/161.8c017e0e.js"><link rel="prefetch" href="/assets/js/162.8b6b067a.js"><link rel="prefetch" href="/assets/js/163.3318acf8.js"><link rel="prefetch" href="/assets/js/164.c74f4c87.js"><link rel="prefetch" href="/assets/js/165.d292dced.js"><link rel="prefetch" href="/assets/js/166.0806cc92.js"><link rel="prefetch" href="/assets/js/167.c869e9ea.js"><link rel="prefetch" href="/assets/js/168.934c5fce.js"><link rel="prefetch" href="/assets/js/169.e7df9c01.js"><link rel="prefetch" href="/assets/js/17.a5b7ddda.js"><link rel="prefetch" href="/assets/js/170.aff8a98c.js"><link rel="prefetch" href="/assets/js/171.1b560d6b.js"><link rel="prefetch" href="/assets/js/172.0b2b1b8b.js"><link rel="prefetch" href="/assets/js/173.c3406762.js"><link rel="prefetch" href="/assets/js/174.3f192f7d.js"><link rel="prefetch" href="/assets/js/175.22511eeb.js"><link rel="prefetch" href="/assets/js/176.42c16672.js"><link rel="prefetch" href="/assets/js/177.f06a0494.js"><link rel="prefetch" href="/assets/js/178.a20d877a.js"><link rel="prefetch" href="/assets/js/179.ddda5176.js"><link rel="prefetch" href="/assets/js/18.0cd3dcc1.js"><link rel="prefetch" href="/assets/js/180.7b1b5ff0.js"><link rel="prefetch" href="/assets/js/181.49569617.js"><link rel="prefetch" href="/assets/js/182.62cf10d7.js"><link rel="prefetch" href="/assets/js/183.2a23c37e.js"><link rel="prefetch" href="/assets/js/184.dddf24df.js"><link rel="prefetch" href="/assets/js/185.5bd1da7c.js"><link rel="prefetch" href="/assets/js/186.f39f3cdd.js"><link rel="prefetch" href="/assets/js/187.20479939.js"><link rel="prefetch" href="/assets/js/188.7861993f.js"><link rel="prefetch" href="/assets/js/189.5a2bbf8d.js"><link rel="prefetch" href="/assets/js/19.9eab9d0e.js"><link rel="prefetch" href="/assets/js/190.eea92ea6.js"><link rel="prefetch" href="/assets/js/191.519471b7.js"><link rel="prefetch" href="/assets/js/192.d8d42f99.js"><link rel="prefetch" href="/assets/js/193.9e2ca160.js"><link rel="prefetch" href="/assets/js/194.0b36a25d.js"><link rel="prefetch" href="/assets/js/195.cacf975f.js"><link rel="prefetch" href="/assets/js/196.fa498730.js"><link rel="prefetch" href="/assets/js/197.1d055572.js"><link rel="prefetch" href="/assets/js/198.aad7181d.js"><link rel="prefetch" href="/assets/js/199.09a98b01.js"><link rel="prefetch" href="/assets/js/20.48a2617b.js"><link rel="prefetch" href="/assets/js/200.5039c32a.js"><link rel="prefetch" href="/assets/js/201.3c7b09e8.js"><link rel="prefetch" href="/assets/js/202.f715301d.js"><link rel="prefetch" href="/assets/js/203.007f9397.js"><link rel="prefetch" href="/assets/js/204.db114c77.js"><link rel="prefetch" href="/assets/js/205.d4c02db1.js"><link rel="prefetch" href="/assets/js/206.f887ee07.js"><link rel="prefetch" href="/assets/js/207.1e53e9a9.js"><link rel="prefetch" href="/assets/js/208.7f4d355c.js"><link rel="prefetch" href="/assets/js/209.7b4c6378.js"><link rel="prefetch" href="/assets/js/21.5add859d.js"><link rel="prefetch" href="/assets/js/210.24c31815.js"><link rel="prefetch" href="/assets/js/211.aa6fce57.js"><link rel="prefetch" href="/assets/js/212.1c67f898.js"><link rel="prefetch" href="/assets/js/213.99c987a9.js"><link rel="prefetch" href="/assets/js/214.9d8f007b.js"><link rel="prefetch" href="/assets/js/215.e2948462.js"><link rel="prefetch" href="/assets/js/216.6b78e7a9.js"><link rel="prefetch" href="/assets/js/217.e32c8947.js"><link rel="prefetch" href="/assets/js/218.4526f427.js"><link rel="prefetch" href="/assets/js/219.f1642fca.js"><link rel="prefetch" href="/assets/js/22.aa0aad47.js"><link rel="prefetch" href="/assets/js/220.321d6408.js"><link rel="prefetch" href="/assets/js/221.c216cfb7.js"><link rel="prefetch" href="/assets/js/222.b077686a.js"><link rel="prefetch" href="/assets/js/223.92ceb0e8.js"><link rel="prefetch" href="/assets/js/224.cc3ff46f.js"><link rel="prefetch" href="/assets/js/225.cd5715f6.js"><link rel="prefetch" href="/assets/js/226.416438e0.js"><link rel="prefetch" href="/assets/js/227.5994cd6c.js"><link rel="prefetch" href="/assets/js/228.160dc745.js"><link rel="prefetch" href="/assets/js/229.db4aaf48.js"><link rel="prefetch" href="/assets/js/23.9349cdce.js"><link rel="prefetch" href="/assets/js/230.ecadeb4e.js"><link rel="prefetch" href="/assets/js/231.fc222f6d.js"><link rel="prefetch" href="/assets/js/232.133f7103.js"><link rel="prefetch" href="/assets/js/233.5d5edda3.js"><link rel="prefetch" href="/assets/js/234.eaff0e0e.js"><link rel="prefetch" href="/assets/js/235.e8af7a8e.js"><link rel="prefetch" href="/assets/js/236.46228b26.js"><link rel="prefetch" href="/assets/js/237.818d7417.js"><link rel="prefetch" href="/assets/js/238.8a846d80.js"><link rel="prefetch" href="/assets/js/239.b6625430.js"><link rel="prefetch" href="/assets/js/24.e9a44242.js"><link rel="prefetch" href="/assets/js/240.2a60aed1.js"><link rel="prefetch" href="/assets/js/241.2b22e2ea.js"><link rel="prefetch" href="/assets/js/242.3e7d1040.js"><link rel="prefetch" href="/assets/js/243.3afb5bbf.js"><link rel="prefetch" href="/assets/js/244.0ae11737.js"><link rel="prefetch" href="/assets/js/245.74aa9496.js"><link rel="prefetch" href="/assets/js/246.8798fb8f.js"><link rel="prefetch" href="/assets/js/247.c4316c09.js"><link rel="prefetch" href="/assets/js/248.af9940b7.js"><link rel="prefetch" href="/assets/js/249.210a94a5.js"><link rel="prefetch" href="/assets/js/25.b128a01b.js"><link rel="prefetch" href="/assets/js/250.75d62abd.js"><link rel="prefetch" href="/assets/js/251.f79da3c7.js"><link rel="prefetch" href="/assets/js/252.4915032e.js"><link rel="prefetch" href="/assets/js/253.1ec35ae4.js"><link rel="prefetch" href="/assets/js/254.d7696504.js"><link rel="prefetch" href="/assets/js/255.4a4f4502.js"><link rel="prefetch" href="/assets/js/256.7b851854.js"><link rel="prefetch" href="/assets/js/257.8963632d.js"><link rel="prefetch" href="/assets/js/258.f642dace.js"><link rel="prefetch" href="/assets/js/259.9046efe6.js"><link rel="prefetch" href="/assets/js/26.7f2a40cb.js"><link rel="prefetch" href="/assets/js/260.79826cb0.js"><link rel="prefetch" href="/assets/js/261.f92bd44d.js"><link rel="prefetch" href="/assets/js/262.028c7ca1.js"><link rel="prefetch" href="/assets/js/263.847f2ecd.js"><link rel="prefetch" href="/assets/js/264.333f2e54.js"><link rel="prefetch" href="/assets/js/265.78042d20.js"><link rel="prefetch" href="/assets/js/266.d1105534.js"><link rel="prefetch" href="/assets/js/267.54d06ea4.js"><link rel="prefetch" href="/assets/js/268.4d0a3491.js"><link rel="prefetch" href="/assets/js/269.79467da4.js"><link rel="prefetch" href="/assets/js/27.ce9f4c55.js"><link rel="prefetch" href="/assets/js/270.22b51924.js"><link rel="prefetch" href="/assets/js/271.1c816de8.js"><link rel="prefetch" href="/assets/js/272.c4047563.js"><link rel="prefetch" href="/assets/js/273.73df57a1.js"><link rel="prefetch" href="/assets/js/274.c027fc92.js"><link rel="prefetch" href="/assets/js/275.de21ac0e.js"><link rel="prefetch" href="/assets/js/276.6eb7f53d.js"><link rel="prefetch" href="/assets/js/277.7fc02829.js"><link rel="prefetch" href="/assets/js/278.6f938298.js"><link rel="prefetch" href="/assets/js/279.590856b0.js"><link rel="prefetch" href="/assets/js/28.4f132782.js"><link rel="prefetch" href="/assets/js/280.b2e8242c.js"><link rel="prefetch" href="/assets/js/281.2434d9b7.js"><link rel="prefetch" href="/assets/js/282.510698fe.js"><link rel="prefetch" href="/assets/js/283.34dbe35d.js"><link rel="prefetch" href="/assets/js/284.5d365cf7.js"><link rel="prefetch" href="/assets/js/285.72ad1a72.js"><link rel="prefetch" href="/assets/js/286.169b1595.js"><link rel="prefetch" href="/assets/js/287.538711ac.js"><link rel="prefetch" href="/assets/js/288.e3a2a096.js"><link rel="prefetch" href="/assets/js/289.cbc2993f.js"><link rel="prefetch" href="/assets/js/29.63ae258b.js"><link rel="prefetch" href="/assets/js/290.e8cea10d.js"><link rel="prefetch" href="/assets/js/291.8879acdb.js"><link rel="prefetch" href="/assets/js/292.b26d1960.js"><link rel="prefetch" href="/assets/js/293.22d735c8.js"><link rel="prefetch" href="/assets/js/294.bddd528e.js"><link rel="prefetch" href="/assets/js/295.2c9d231a.js"><link rel="prefetch" href="/assets/js/296.8de13933.js"><link rel="prefetch" href="/assets/js/30.7579196a.js"><link rel="prefetch" href="/assets/js/31.caba5080.js"><link rel="prefetch" href="/assets/js/32.dcfaa74c.js"><link rel="prefetch" href="/assets/js/33.e3eb78ab.js"><link rel="prefetch" href="/assets/js/34.965c9da4.js"><link rel="prefetch" href="/assets/js/35.f48f95b0.js"><link rel="prefetch" href="/assets/js/36.aec8d64d.js"><link rel="prefetch" href="/assets/js/37.a1bff4f6.js"><link rel="prefetch" href="/assets/js/38.ee96ec81.js"><link rel="prefetch" href="/assets/js/39.6bfc448d.js"><link rel="prefetch" href="/assets/js/4.c001efb5.js"><link rel="prefetch" href="/assets/js/40.eff59a54.js"><link rel="prefetch" href="/assets/js/41.2ea12a58.js"><link rel="prefetch" href="/assets/js/42.44c7d76e.js"><link rel="prefetch" href="/assets/js/43.c32cbde1.js"><link rel="prefetch" href="/assets/js/44.3d57c263.js"><link rel="prefetch" href="/assets/js/45.f95d97ef.js"><link rel="prefetch" href="/assets/js/46.c4d324a2.js"><link rel="prefetch" href="/assets/js/47.134ad778.js"><link rel="prefetch" href="/assets/js/48.49d9eeec.js"><link rel="prefetch" href="/assets/js/49.b4b827b9.js"><link rel="prefetch" href="/assets/js/5.ef473464.js"><link rel="prefetch" href="/assets/js/50.a6623a09.js"><link rel="prefetch" href="/assets/js/51.65203ef9.js"><link rel="prefetch" href="/assets/js/52.3e44eeee.js"><link rel="prefetch" href="/assets/js/53.87325928.js"><link rel="prefetch" href="/assets/js/54.61302a53.js"><link rel="prefetch" href="/assets/js/55.5fd0fa99.js"><link rel="prefetch" href="/assets/js/56.795b4d47.js"><link rel="prefetch" href="/assets/js/57.a4d59171.js"><link rel="prefetch" href="/assets/js/58.168be758.js"><link rel="prefetch" href="/assets/js/59.ddc9ae90.js"><link rel="prefetch" href="/assets/js/6.fa8ed6b8.js"><link rel="prefetch" href="/assets/js/60.c1436c29.js"><link rel="prefetch" href="/assets/js/61.63504acc.js"><link rel="prefetch" href="/assets/js/62.c32e8dd4.js"><link rel="prefetch" href="/assets/js/63.44a8fbb7.js"><link rel="prefetch" href="/assets/js/64.4362b1a3.js"><link rel="prefetch" href="/assets/js/65.d4651b8d.js"><link rel="prefetch" href="/assets/js/66.be813c20.js"><link rel="prefetch" href="/assets/js/67.a512a868.js"><link rel="prefetch" href="/assets/js/68.ff4f0a9d.js"><link rel="prefetch" href="/assets/js/69.8a85a479.js"><link rel="prefetch" href="/assets/js/7.b092023b.js"><link rel="prefetch" href="/assets/js/70.1c29d20f.js"><link rel="prefetch" href="/assets/js/71.d5b50c61.js"><link rel="prefetch" href="/assets/js/72.6c2871b6.js"><link rel="prefetch" href="/assets/js/73.25d468a8.js"><link rel="prefetch" href="/assets/js/74.1c03fc27.js"><link rel="prefetch" href="/assets/js/75.4a942078.js"><link rel="prefetch" href="/assets/js/76.e2ddea3e.js"><link rel="prefetch" href="/assets/js/77.eb509925.js"><link rel="prefetch" href="/assets/js/78.c06149f5.js"><link rel="prefetch" href="/assets/js/79.3ddbd0e1.js"><link rel="prefetch" href="/assets/js/8.e7965bc2.js"><link rel="prefetch" href="/assets/js/80.175d27ae.js"><link rel="prefetch" href="/assets/js/81.1c416e83.js"><link rel="prefetch" href="/assets/js/82.d562a6f2.js"><link rel="prefetch" href="/assets/js/83.b8a717c3.js"><link rel="prefetch" href="/assets/js/84.e90f5925.js"><link rel="prefetch" href="/assets/js/85.7ee97e96.js"><link rel="prefetch" href="/assets/js/86.31fe2604.js"><link rel="prefetch" href="/assets/js/87.3c5e7d69.js"><link rel="prefetch" href="/assets/js/88.6248ecf3.js"><link rel="prefetch" href="/assets/js/89.7a56969a.js"><link rel="prefetch" href="/assets/js/9.2bb06108.js"><link rel="prefetch" href="/assets/js/90.f9a8585f.js"><link rel="prefetch" href="/assets/js/91.979a8417.js"><link rel="prefetch" href="/assets/js/92.f08e40b4.js"><link rel="prefetch" href="/assets/js/93.a2215be8.js"><link rel="prefetch" href="/assets/js/94.7c010fd8.js"><link rel="prefetch" href="/assets/js/95.0f757d64.js"><link rel="prefetch" href="/assets/js/96.e0716238.js"><link rel="prefetch" href="/assets/js/97.c088a7ea.js"><link rel="prefetch" href="/assets/js/98.6e50da8f.js"><link rel="prefetch" href="/assets/js/99.92605dbd.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ee07844b.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu have-body-img"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/EB-logo.png" alt="Vic's blog" class="logo"> <span class="site-name can-hide">Vic's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/pages/5d463fbdb172d43b/" class="nav-link">Vue</a></li><li class="dropdown-subitem"><a href="/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-subitem"><a href="/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》笔记</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》笔记</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》笔记</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》笔记</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript笔记</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结笔记</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后台" class="dropdown-title"><a href="/back/" class="link-title">后台</a> <span class="title" style="display:none;">后台</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/4e4caa/" class="nav-link">微服务</a></li><li class="dropdown-item"><!----> <a href="/pages/3ef014/" class="nav-link">Database</a></li><li class="dropdown-item"><!----> <a href="/pages/f22439/" class="nav-link">Python</a></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/interview/" class="nav-link">Java面试宝典</a></li><li class="dropdown-subitem"><a href="/note/ai/" class="nav-link">《一个人工智能的诞生》笔记</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》学习笔记</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="脑图" class="dropdown-title"><a href="/mind/" class="link-title">脑图</a> <span class="title" style="display:none;">脑图</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mind/800e44/" class="nav-link">大数据</a></li><li class="dropdown-item"><!----> <a href="/mind/3cc0a2/" class="nav-link">微服务</a></li><li class="dropdown-item"><!----> <a href="/mind/7af745/" class="nav-link">Java面试</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><a href="/pages/beb6c0bd8a66cea6/" class="link-title">收藏</a> <span class="title" style="display:none;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/beb6c0bd8a66cea6/" class="nav-link">网站</a></li><li class="dropdown-item"><!----> <a href="/pages/eee83a9211a70f9d/" class="nav-link">资源</a></li><li class="dropdown-item"><!----> <a href="/pages/12df8ace52d493f6/" class="nav-link">Vue资源</a></li><li class="dropdown-item"><!----> <a href="/pages/fddac8/" class="nav-link">Java面试真题汇总</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/vicxsl/vicxsl.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="/img/profile.jpg"> <div class="blogger-info"><h3>Vic xu</h3> <span>永远期待美好的事情将会发生</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>前端文章</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/8143cc480faf9a11/" class="nav-link">JavaScript</a></li><li class="dropdown-subitem"><a href="/pages/5d463fbdb172d43b/" class="nav-link">Vue</a></li><li class="dropdown-subitem"><a href="/pages/8309a5b876fc95e3/" class="nav-link">HTML</a></li><li class="dropdown-subitem"><a href="/pages/0a83b083bdf257cb/" class="nav-link">CSS</a></li></ul></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/javascript/" class="nav-link">《JavaScript教程》笔记</a></li><li class="dropdown-subitem"><a href="/note/js/" class="nav-link">《JavaScript高级程序设计》笔记</a></li><li class="dropdown-subitem"><a href="/note/es6/" class="nav-link">《ES6 教程》笔记</a></li><li class="dropdown-subitem"><a href="/note/vue/" class="nav-link">《Vue》笔记</a></li><li class="dropdown-subitem"><a href="/note/typescript-axios/" class="nav-link">《TypeScript 从零实现 axios》</a></li><li class="dropdown-subitem"><a href="/pages/51afd6/" class="nav-link">TypeScript笔记</a></li><li class="dropdown-subitem"><a href="/pages/4643cd/" class="nav-link">JS设计模式总结笔记</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后台" class="dropdown-title"><a href="/back/" class="link-title">后台</a> <span class="title" style="display:none;">后台</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/4e4caa/" class="nav-link">微服务</a></li><li class="dropdown-item"><!----> <a href="/pages/3ef014/" class="nav-link">Database</a></li><li class="dropdown-item"><!----> <a href="/pages/f22439/" class="nav-link">Python</a></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/interview/" class="nav-link">Java面试宝典</a></li><li class="dropdown-subitem"><a href="/note/ai/" class="nav-link">《一个人工智能的诞生》笔记</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="技术" class="dropdown-title"><a href="/technology/" class="link-title">技术</a> <span class="title" style="display:none;">技术</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/9a7ee40fc232253e/" class="nav-link">技术文档</a></li><li class="dropdown-item"><!----> <a href="/pages/4c778760be26d8b3/" class="nav-link">GitHub技巧</a></li><li class="dropdown-item"><!----> <a href="/pages/41f87d890d0a02af/" class="nav-link">博客搭建</a></li><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/note/git/" class="nav-link">《Git》学习笔记</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/f2a556/" class="nav-link">学习</a></li><li class="dropdown-item"><!----> <a href="/pages/aea6571b7a8bae86/" class="nav-link">面试</a></li><li class="dropdown-item"><!----> <a href="/pages/2d615df9a36a98ed/" class="nav-link">心情杂货</a></li><li class="dropdown-item"><!----> <a href="/pages/baaa02/" class="nav-link">实用技巧</a></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="脑图" class="dropdown-title"><a href="/mind/" class="link-title">脑图</a> <span class="title" style="display:none;">脑图</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/mind/800e44/" class="nav-link">大数据</a></li><li class="dropdown-item"><!----> <a href="/mind/3cc0a2/" class="nav-link">微服务</a></li><li class="dropdown-item"><!----> <a href="/mind/7af745/" class="nav-link">Java面试</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><a href="/pages/beb6c0bd8a66cea6/" class="link-title">收藏</a> <span class="title" style="display:none;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/beb6c0bd8a66cea6/" class="nav-link">网站</a></li><li class="dropdown-item"><!----> <a href="/pages/eee83a9211a70f9d/" class="nav-link">资源</a></li><li class="dropdown-item"><!----> <a href="/pages/12df8ace52d493f6/" class="nav-link">Vue资源</a></li><li class="dropdown-item"><!----> <a href="/pages/fddac8/" class="nav-link">Java面试真题汇总</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/vicxsl/vicxsl.github.io" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Java快速面试</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/572e34/" class="sidebar-link">Java基础知识面试题</a></li><li><a href="/pages/e242c6/" aria-current="page" class="active sidebar-link">Java集合容器面试题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/e242c6/#什么是集合" class="sidebar-link">什么是集合</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#集合的特点" class="sidebar-link">集合的特点</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#集合和数组的区别" class="sidebar-link">集合和数组的区别</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#使用集合框架的好处" class="sidebar-link">使用集合框架的好处</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#常用的集合类有哪些" class="sidebar-link">常用的集合类有哪些？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#list-set-map三者的区别" class="sidebar-link">List，Set，Map三者的区别？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#list、set、map-是否继承自-collection-接口" class="sidebar-link">List、Set、Map 是否继承自 Collection 接口？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#list、map、set-三个接口存取元素时-各有什么特点" class="sidebar-link">List、Map、Set 三个接口存取元素时，各有什么特点？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#集合框架底层数据结构" class="sidebar-link">集合框架底层数据结构</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#哪些集合类是线程安全的" class="sidebar-link">哪些集合类是线程安全的？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#java集合的快速失败机制-fail-fast" class="sidebar-link">Java集合的快速失败机制 “fail-fast”？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#collection接口" class="sidebar-link">Collection接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/e242c6/#list接口" class="sidebar-link">List接口</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#iterator-和-listiterator-有什么区别" class="sidebar-link">Iterator 和 ListIterator 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#遍历一个-list-有哪些不同的方式-每种方法的实现原理是什么-java-中-list遍历的最佳实践是什么" class="sidebar-link">遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List遍历的最佳实践是什么？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#说一下-arraylist-的优缺点" class="sidebar-link">说一下 ArrayList 的优缺点</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#arraylist-和-linkedlist-的区别是什么" class="sidebar-link">ArrayList 和 LinkedList 的区别是什么？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#插入数据时-arraylist、linkedlist、vector谁速度较快-阐述arraylist、vector、linkedlist-的存储性能和特性" class="sidebar-link">插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述ArrayList、Vector、LinkedList 的存储性能和特性？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#多线程场景下如何使用-arraylist" class="sidebar-link">多线程场景下如何使用 ArrayList？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#list-和-set-的区别" class="sidebar-link">List 和 Set 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#set接口" class="sidebar-link">Set接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/e242c6/#说一下-hashset-的实现原理" class="sidebar-link">说一下 HashSet 的实现原理？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#hashset如何检查重复-hashset是如何保证数据不可重复的" class="sidebar-link">HashSet如何检查重复？HashSet是如何保证数据不可重复的？</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#hashcode-与equals-的相关规定" class="sidebar-link">hashCode（）与equals（）的相关规定：</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#与equals的区别" class="sidebar-link">==与equals的区别</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#hashset与hashmap的区别" class="sidebar-link">HashSet与HashMap的区别</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#map接口" class="sidebar-link">Map接口</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/e242c6/#什么是hash算法" class="sidebar-link">什么是Hash算法</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#什么是链表" class="sidebar-link">什么是链表</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#说一下hashmap的实现原理" class="sidebar-link">说一下HashMap的实现原理？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#hashmap在jdk1-7和jdk1-8中有哪些不同-hashmap的底层实现" class="sidebar-link">HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#什么是红黑树" class="sidebar-link">什么是红黑树</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#红黑树" class="sidebar-link">红黑树</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#hashmap的put方法的具体流程" class="sidebar-link">HashMap的put方法的具体流程？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#hashmap的扩容操作是怎么实现的" class="sidebar-link">HashMap的扩容操作是怎么实现的？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#hashmap是怎么解决哈希冲突的" class="sidebar-link">HashMap是怎么解决哈希冲突的？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#总结" class="sidebar-link">总结</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#hashmap-与-hashtable-有什么区别" class="sidebar-link">HashMap 与 HashTable 有什么区别？</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#什么是treemap-简介" class="sidebar-link">什么是TreeMap 简介</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#hashmap-和-concurrenthashmap-的区别" class="sidebar-link">HashMap 和 ConcurrentHashMap 的区别</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#concurrenthashmap-和-hashtable-的区别" class="sidebar-link">ConcurrentHashMap 和 Hashtable 的区别？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#concurrenthashmap-底层具体实现知道吗-实现原理是什么" class="sidebar-link">ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/e242c6/#jdk1-7" class="sidebar-link">JDK1.7</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#jdk1-8" class="sidebar-link">JDK1.8</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#辅助工具类" class="sidebar-link">辅助工具类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/e242c6/#array-和-arraylist-有何区别" class="sidebar-link">Array 和 ArrayList 有何区别？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#comparable-和-comparator的区别" class="sidebar-link">comparable 和 comparator的区别？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#collection-和-collections-有什么区别" class="sidebar-link">Collection 和 Collections 有什么区别？</a></li><li class="sidebar-sub-header"><a href="/pages/e242c6/#treemap-和-treeset-在排序时如何比较元素-collections-工具类中的-sort-方法如何比较元素" class="sidebar-link">TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</a></li></ul></li></ul></li><li><a href="/pages/bb678c/" class="sidebar-link">并发编程面试题</a></li><li><a href="/pages/0f5521/" class="sidebar-link">Java异常面试题</a></li><li><a href="/pages/ff7c7b/" class="sidebar-link">Java虚拟机面试题</a></li><li><a href="/pages/00173d/" class="sidebar-link">Java-IO流</a></li><li><a href="/pages/944d10/" class="sidebar-link">Spring面试题</a></li><li><a href="/pages/47308e/" class="sidebar-link">Spring MVC面试题</a></li><li><a href="/pages/bd9aaf/" class="sidebar-link">Spring Cloud面试题</a></li><li><a href="/pages/908db0/" class="sidebar-link">Spring Boot面试题</a></li><li><a href="/pages/d724dd/" class="sidebar-link">MyBatis面试题</a></li><li><a href="/pages/4976bf/" class="sidebar-link">Netty面试题</a></li><li><a href="/pages/4b14c3/" class="sidebar-link">Dubbo面试题</a></li><li><a href="/pages/cfbf50/" class="sidebar-link">Redis面试题</a></li><li><a href="/pages/9e346b/" class="sidebar-link">MySQL数据库面试题</a></li><li><a href="/pages/6000e7/" class="sidebar-link">ZooKeeper面试题</a></li><li><a href="/pages/f93597/" class="sidebar-link">消息中间件MQ与RabbitMQ面试题</a></li><li><a href="/pages/b7bd55/" class="sidebar-link">Linux面试题</a></li><li><a href="/pages/bc63c4/" class="sidebar-link">Tomcat面试题</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>面试攻略</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>程序人生</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>高效学习</span> <span class="arrow right"></span></p> <!----></section></li></ul> <div class="sidebar-slot sidebar-slot-bottom"><!-- 正方形 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="3508773082"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div></aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-70a2d273><div class="articleInfo" data-v-70a2d273><ul class="breadcrumbs" data-v-70a2d273><li data-v-70a2d273><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-70a2d273></a></li> <li data-v-70a2d273><a href="/categories/?category=Java%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8" title="分类" data-v-70a2d273>Java面试宝典</a></li> <li data-v-70a2d273><a href="/categories/?category=Java%E5%BF%AB%E9%80%9F%E9%9D%A2%E8%AF%95" title="分类" data-v-70a2d273>Java快速面试</a></li> <!----></ul> <div class="info" data-v-70a2d273><div title="作者" class="author iconfont icon-touxiang" data-v-70a2d273><a href="https://github.com/vicxsl" target="_blank" title="作者" class="beLink" data-v-70a2d273>xushengli</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-70a2d273><a href="javascript:;" data-v-70a2d273>2021-06-29</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">
          Java集合容器面试题
        </h1> <div class="page-slot page-slot-top"><!-- 固定100% * 90px可显示，max-height:90px未见显示-->
     <ins class="adsbygoogle"
          style="display:inline-block;width:100%;max-height:90px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6625304284"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="theme-vdoing-content content__default"><h1 id="集合容器概述"><a href="#集合容器概述" class="header-anchor">#</a> 集合容器概述</h1> <h2 id="什么是集合"><a href="#什么是集合" class="header-anchor">#</a> 什么是集合</h2> <p><strong>集合框架</strong>：用于存储数据对象引用的容器。<code>不是对象的本身</code></p> <p>任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。</p> <p><strong>接口</strong>：表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。</p> <p><strong>实现</strong>：集合接口的具体实现，是重用性很高的数据结构。</p> <p><strong>算法</strong>：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。</p> <h2 id="集合的特点"><a href="#集合的特点" class="header-anchor">#</a> 集合的特点</h2> <p>集合的特点主要有如下两点：</p> <ul><li>对象封装数据，对象多了也需要存储。集合用于存储对象。</li> <li>对象的个数确定可以使用数组，对象的个数不确定的可以用集合。因为集合是可变长度的。</li></ul> <h2 id="集合和数组的区别"><a href="#集合和数组的区别" class="header-anchor">#</a> 集合和数组的区别</h2> <ul><li>数组是固定长度的；<strong>集合可变长度</strong>的。</li> <li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储<strong>引用数据类型</strong>。</li> <li>数组存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型。</li></ul> <p><strong>数据结构</strong>：就是容器中存储数据的方式。</p> <p>对于集合容器，有很多种。因为每一个容器的自身特点不同，其实原理在于每个容器的内部数据结构不同。</p> <p>集合容器在不断向上抽取过程中，出现了集合体系。</p> <h2 id="使用集合框架的好处"><a href="#使用集合框架的好处" class="header-anchor">#</a> 使用集合框架的好处</h2> <ul><li>容量自增长；</li> <li>提供了高性能的数据结构和算法，使编码更轻松，提高了程序速度和质量；</li> <li>允许不同 API 之间的互操作，API之间可以来回传递集合；</li> <li>可以方便地扩展或改写集合，提高代码复用性和可操作性。</li> <li>通过使用JDK自带的集合类，可以降低代码维护和学习新API成本。</li></ul> <h2 id="常用的集合类有哪些"><a href="#常用的集合类有哪些" class="header-anchor">#</a> 常用的集合类有哪些？</h2> <ul><li>Map接口和Collection接口是所有集合框架的父接口：</li> <li>Collection接口的子接口包括：Set接口和List接口</li> <li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li> <li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li> <li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li></ul> <h2 id="list-set-map三者的区别"><a href="#list-set-map三者的区别" class="header-anchor">#</a> List，Set，Map三者的区别？</h2> <p><img src="https://s2.loli.net/2022/06/17/TcSypXIQHsKi8vz.png" alt="image-20220617113046401"></p> <h2 id="list、set、map-是否继承自-collection-接口"><a href="#list、set、map-是否继承自-collection-接口" class="header-anchor">#</a> List、Set、Map 是否继承自 Collection 接口？</h2> <p>Java 容器分为 Collection 和 Map 两大类，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。</p> <h2 id="list、map、set-三个接口存取元素时-各有什么特点"><a href="#list、map、set-三个接口存取元素时-各有什么特点" class="header-anchor">#</a> List、Map、Set 三个接口存取元素时，各有什么特点？</h2> <ul><li><p>Collection集合主要有List和Set两大接口</p> <ul><li><p>List：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</p></li> <li><p>Set：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。</p></li></ul></li> <li><p>Map是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。</p> <ul><li>Map 的常用实现类：HashMap、TreeMap、HashTable、LinkedHashMap、ConcurrentHashMap</li></ul></li></ul> <h2 id="集合框架底层数据结构"><a href="#集合框架底层数据结构" class="header-anchor">#</a> 集合框架底层数据结构</h2> <ul><li>Collection
<ul><li>List
<ul><li>Arraylist： Object数组</li> <li>Vector： Object数组</li> <li>LinkedList： 双向循环链表</li></ul></li> <li>Set
<ul><li>HashSet（无序，唯一）：基于 HashMap 实现的，底层采用 HashMap 来保存元素</li> <li>LinkedHashSet： LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li> <li>TreeSet（有序，唯一）： 红黑树(自平衡的排序二叉树。)</li></ul></li> <li>Map
<ul><li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li> <li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li> <li>HashTable： 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li> <li>TreeMap： 红黑树（自平衡的排序二叉树）</li></ul></li></ul></li></ul> <h2 id="哪些集合类是线程安全的"><a href="#哪些集合类是线程安全的" class="header-anchor">#</a> 哪些集合类是线程安全的？</h2> <ul><li>Vector：就比Arraylist多了个synchronized （线程安全），因为效率较低，现在已经不太建议使用。<code>可以使用CopyOnWriteArrayList</code></li> <li>hashTable：就比hashMap多了个synchronized (线程安全)，不建议使用。</li> <li>ConcurrentHashMap：是Java5中支持高并发、高吞吐量的线程安全HashMap实现。它由Segment数组结构和HashEntry数组结构组成。Segment数组在ConcurrentHashMap里扮演锁的角色，HashEntry则用于存储键-值对数据。一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构；一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素；每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。（推荐使用）<code>Segment锁就是分段锁</code></li></ul> <h2 id="java集合的快速失败机制-fail-fast"><a href="#java集合的快速失败机制-fail-fast" class="header-anchor">#</a> Java集合的快速失败机制 “fail-fast”？</h2> <p>是java集合的一种错误检测机制，当多个线程对集合进行结构上的改变的操作时，有可能会产生fail-fast 机制。</p> <ul><li><p>例如：假设存在两个线程（线程1、线程2），线程1通过Iterator在遍历集合A中的元素，在某个时候线程2修改了集合A的结构（是结构上面的修改，而不是简单的修改集合元素的内容），那么这个时候程序就会抛出 ConcurrentModificationException 异常，从而产生fail-fast机制。</p></li> <li><p>原因：迭代器在遍历时直接访问集合中的内容，并且在遍历过程中使用一个 modCount 变量。集合在被遍历期间如果内容发生变化，就会改变modCount的值。每当迭代器使用hashNext()/next()遍历下一个元素之前，都会检测modCount变量是否为expectedmodCount值，是的话就返回遍历；否则抛出异常，终止遍历。</p></li> <li><p>解决办法：</p></li></ul> <ol><li>在遍历过程中，所有涉及到改变modCount值得地方全部加上synchronized。</li> <li>使用CopyOnWriteArrayList来替换ArrayList</li></ol> <h2 id="collection接口"><a href="#collection接口" class="header-anchor">#</a> Collection接口</h2> <h3 id="list接口"><a href="#list接口" class="header-anchor">#</a> List接口</h3> <h4 id="迭代器-iterator-是什么"><a href="#迭代器-iterator-是什么" class="header-anchor">#</a> 迭代器 Iterator 是什么？</h4> <p>Iterator 接口提供遍历任何 Collection 的接口。我们可以从一个 Collection 中使用迭代器方法来获取迭代器实例。迭代器取代了 Java 集合框架中的 Enumeration，迭代器允许调用者在迭代过程中移除元素。因为所有Collection接继承了Iterator迭代器</p> <h4 id="如何边遍历边移除-collection-中的元素"><a href="#如何边遍历边移除-collection-中的元素" class="header-anchor">#</a> 如何边遍历边移除 Collection 中的元素？</h4> <p>边遍历边修改 Collection 的唯一正确方式是使用 Iterator.remove() 方法</p> <h2 id="iterator-和-listiterator-有什么区别"><a href="#iterator-和-listiterator-有什么区别" class="header-anchor">#</a> Iterator 和 ListIterator 有什么区别？</h2> <p>Iterator 可以遍历 Set 和 List 集合，而 ListIterator 只能遍历 List。
Iterator 只能单向遍历，而 ListIterator 可以双向遍历（向前/后遍历）。
ListIterator 实现 Iterator 接口，然后添加了一些额外的功能，比如添加一个元素、替换一个元素、获取前面或后面元素的索引位置。</p> <h2 id="遍历一个-list-有哪些不同的方式-每种方法的实现原理是什么-java-中-list遍历的最佳实践是什么"><a href="#遍历一个-list-有哪些不同的方式-每种方法的实现原理是什么-java-中-list遍历的最佳实践是什么" class="header-anchor">#</a> 遍历一个 List 有哪些不同的方式？每种方法的实现原理是什么？Java 中 List遍历的最佳实践是什么？</h2> <p>遍历方式有以下几种：</p> <ol><li><p>for 循环遍历，基于计数器。在集合外部维护一个计数器，然后依次读取每一个位置的元素。当读取到最后一个元素后停止。</p></li> <li><p>迭代器遍历，Iterator。Iterator 是面向对象的一个设计模式，目的是屏蔽不同数据集合的特点，统一遍历集合的接口。Java 在 Collections 中支持了 Iterator 模式。</p></li> <li><p>foreach 循环遍历。foreach 内部也是采用了 Iterator 的方式实现，使用时不需要显式声明Iterator 或计数器。优点是代码简洁，不易出错；缺点是只能做简单的遍历，不能在遍历过程中操作数据集合，例如删除、替换。</p></li></ol> <p>最佳实践：Java Collections 框架中提供了一个 RandomAccess 接口，用来标记 List 实现是否支持 Random Access。如果一个数据集合实现了该接口，就意味着它支持 Random Access，按位置读取元素的平均时间复杂度为 O(1)，如ArrayList。如果没有实现该接口，表示不支持 Random Access，如LinkedList。</p> <p>推荐的做法就是，支持 Random Access 的列表可用 for 循环遍历，否则建议用 Iterator 或foreach 遍历。</p> <h2 id="说一下-arraylist-的优缺点"><a href="#说一下-arraylist-的优缺点" class="header-anchor">#</a> 说一下 ArrayList 的优缺点</h2> <ul><li><p>ArrayList的优点如下：</p> <ul><li><p>ArrayList 底层以数组实现，是一种随机访问模式。ArrayList 实现了 RandomAccess 接口，因此查找的时候非常快。</p></li> <li><p>ArrayList 在顺序添加一个元素的时候非常方便。</p></li></ul></li> <li><p>ArrayList 的缺点如下：</p> <ul><li>删除元素的时候，需要做一次元素复制操作。如果要复制的元素很多，那么就会比较耗费性能。</li> <li>插入元素的时候，也需要做一次元素复制操作，缺点同上。</li></ul></li> <li><p>ArrayList 比较适合顺序添加、随机访问的场景。</p></li></ul> <h2 id="arraylist-和-linkedlist-的区别是什么"><a href="#arraylist-和-linkedlist-的区别是什么" class="header-anchor">#</a> ArrayList 和 LinkedList 的区别是什么？</h2> <ul><li>数据结构实现：ArrayList 是动态数组的数据结构实现，而 LinkedList 是双向链表的数据结构实现。</li> <li>随机访问效率：ArrayList 比 LinkedList 在随机访问的时候效率要高，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找。</li> <li>增加和删除效率：在非首尾的增加和删除操作，LinkedList 要比 ArrayList 效率要高，因为ArrayList 增删操作要影响数组内的其他数据的下标。</li> <li>内存空间占用：LinkedList 比 ArrayList 更占内存，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li> <li>线程安全：ArrayList 和 LinkedList 都是不同步的，也就是不保证线程安全；</li> <li>综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。</li> <li>LinkedList 的双向链表也叫双链表，是链表的一种，它的每个数据结点中都有两个指针，分别指向直接后继和直接前驱。所以，从双向链表中的任意一个结点开始，都可以很方便地访问它的前驱结点和后继结点。</li></ul> <h2 id="插入数据时-arraylist、linkedlist、vector谁速度较快-阐述arraylist、vector、linkedlist-的存储性能和特性"><a href="#插入数据时-arraylist、linkedlist、vector谁速度较快-阐述arraylist、vector、linkedlist-的存储性能和特性" class="header-anchor">#</a> 插入数据时，ArrayList、LinkedList、Vector谁速度较快？阐述ArrayList、Vector、LinkedList 的存储性能和特性？</h2> <ul><li>ArrayList和Vector 底层的实现都是使用数组方式存储数据。数组元素数大于实际存储的数据以便增加和插入元素，它们都允许直接按序号索引元素，但是插入元素要涉及数组元素移动等内存操作，所以索引数据快而插入数据慢。</li> <li>Vector 中的方法由于加了 synchronized 修饰，因此 Vector 是线程安全容器，但性能上较ArrayList差。<code>加锁后性能更差</code></li> <li>LinkedList 使用双向链表实现存储，按序号索引数据需要进行前向或后向遍历，但插入数据时只需要记录当前项的前后项即可，所以 LinkedList 插入速度较快。<code>链表插入快</code></li></ul> <h2 id="多线程场景下如何使用-arraylist"><a href="#多线程场景下如何使用-arraylist" class="header-anchor">#</a> 多线程场景下如何使用 ArrayList？</h2> <p>ArrayList 不是线程安全的，如果遇到多线程场景，可以通过 Collections 的 synchronizedList 方法将其转换成线程安全的容器后再使用。例如像下面这样：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> synchronizedList <span class="token operator">=</span> <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">synchronizedList</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span>
synchronizedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;aaa&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
synchronizedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">&quot;bbb&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> synchronizedList<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>synchronizedList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="list-和-set-的区别"><a href="#list-和-set-的区别" class="header-anchor">#</a> List 和 Set 的区别</h2> <ul><li>List , Set 都是继承自Collection 接口</li> <li>List 特点：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。</li> <li>Set 特点：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及TreeSet。</li> <li>另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。</li> <li>Set和List对比
<ul><li>Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。</li> <li>List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变。</li></ul></li></ul> <h2 id="set接口"><a href="#set接口" class="header-anchor">#</a> Set接口</h2> <h3 id="说一下-hashset-的实现原理"><a href="#说一下-hashset-的实现原理" class="header-anchor">#</a> 说一下 HashSet 的实现原理？</h3> <p><strong>HashSet 是基于 HashMap 实现的</strong>，HashSet的值存放于HashMap的key上，HashMap的value统一为present，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层HashMap 的相关方法来完成，HashSet 不允许重复的值。</p> <h3 id="hashset如何检查重复-hashset是如何保证数据不可重复的"><a href="#hashset如何检查重复-hashset是如何保证数据不可重复的" class="header-anchor">#</a> HashSet如何检查重复？HashSet是如何保证数据不可重复的？</h3> <ul><li><p>向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。</p></li> <li><p>HashSet 中的add ()方法会使用HashMap 的put()方法。</p></li> <li><p>HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（HashMap 比较key是否相等是先比较hashcode 再比较equals ）。</p></li> <li><p>以下是HashSet 部分源码：</p></li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span> PRESENT <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">private</span> <span class="token keyword">transient</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map<span class="token punctuation">;</span>
<span class="token keyword">public</span> <span class="token class-name">HashSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 调用HashMap的put方法,PRESENT是一个至始至终都相同的虚值</span>
<span class="token keyword">return</span> map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> PRESENT<span class="token punctuation">)</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h2 id="hashcode-与equals-的相关规定"><a href="#hashcode-与equals-的相关规定" class="header-anchor">#</a> hashCode（）与equals（）的相关规定：</h2> <ol><li>如果两个对象相等，则hashcode一定也是相同的
hashCode是jdk根据对象的地址或者字符串或者数字算出来的int类型的数值</li> <li>两个对象相等,对两个equals方法返回true</li> <li>两个对象有相同的hashcode值，它们也不一定是相等的</li> <li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li> <li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）。</li></ol> <h2 id="与equals的区别"><a href="#与equals的区别" class="header-anchor">#</a> ==与equals的区别</h2> <ol><li>==是判断两个变量或实例是不是指向同一个内存空间，equals是判断两个变量或实例所指向的内存空间的值是不是相同 <code>值相同</code></li> <li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li></ol> <h2 id="hashset与hashmap的区别"><a href="#hashset与hashmap的区别" class="header-anchor">#</a> HashSet与HashMap的区别</h2> <table><thead><tr><th>HashMap</th> <th>HashSet</th></tr></thead> <tbody><tr><td>实现Set接口</td> <td>实现了Map接口</td></tr> <tr><td>存储键值对</td> <td>仅存储对象</td></tr> <tr><td>调用put（）向map中添加元素</td> <td>调用add（）方法向Set中添加元素</td></tr> <tr><td>HashMap使用键（Key）计算Hashcode</td> <td>HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false</td></tr> <tr><td>HashMap相对于HashSet较快，因为它是使用唯一的键获取对象</td> <td>HashSet较HashMap来说比较慢</td></tr></tbody></table> <h2 id="map接口"><a href="#map接口" class="header-anchor">#</a> Map接口</h2> <h3 id="什么是hash算法"><a href="#什么是hash算法" class="header-anchor">#</a> 什么是Hash算法</h3> <p>哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。</p> <h3 id="什么是链表"><a href="#什么是链表" class="header-anchor">#</a> 什么是链表</h3> <p>链表是可以将物理地址上不连续的数据连接起来，通过指针来对物理地址进行操作，实现增删改查等功能。</p> <ul><li>链表大致分为单链表和双向链表</li></ul> <ol><li>单链表:每个节点包含两部分,一部分存放数据变量的data,另一部分是指向下一节点的next指针</li></ol> <p><img src="https://s2.loli.net/2022/06/17/n3AUyNSYuIMlPwv.png" alt="image-20220617180207368"></p> <ol start="2"><li>双向链表:除了包含单链表的部分,还增加的pre前一个节点的指针</li></ol> <p><img src="https://s2.loli.net/2022/06/17/GENS2UCbPRZiMo9.png" alt="image-20220617180246921"></p> <ul><li>插入删除速度快（因为有next指针指向其下一个节点，通过改变指针的指向可以方便的增加删除元素）</li> <li>内存利用率高，不会浪费内存（<strong>可以使用内存中细小的不连续空间</strong>（大于node节点的大小），并且在需要空间的时候才创建空间）大小没有固定，拓展很灵活。</li> <li>链表的缺点
<ul><li>不能随机查找，必须从第一个开始遍历，查找效率低</li></ul></li></ul> <h3 id="说一下hashmap的实现原理"><a href="#说一下hashmap的实现原理" class="header-anchor">#</a> 说一下HashMap的实现原理？</h3> <ul><li><p>HashMap概述： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p></li> <li><p>HashMap的数据结构： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。</p></li> <li><p><strong>HashMap 基于 Hash 算法实现的</strong></p></li></ul> <ol><li><p>当我们往HashMap中put元素时，<strong>利用key的hashCode重新hash计算出当前对象的元素在数组中的下标</strong></p></li> <li><p>存储时，如果出现hash值相同的key，此时有两种情况。
(1)如果key相同，则覆盖原始值；
(2)如果key不同（出现冲突），则将当前的key-value放入链表中</p></li> <li><p>获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。</p></li> <li><p>理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，<strong>核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中</strong>，一旦发现冲突就在链表中做进一步的对比。</p></li> <li><p>需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)</p></li></ol> <h3 id="hashmap在jdk1-7和jdk1-8中有哪些不同-hashmap的底层实现"><a href="#hashmap在jdk1-7和jdk1-8中有哪些不同-hashmap的底层实现" class="header-anchor">#</a> HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现</h3> <p>在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将<strong>数组和链表结合在一起，发挥两者各自的优势</strong>，使用一种叫做拉链法的方式可以解决哈希冲突。</p> <blockquote><p>拉链法的数据结构很形象</p></blockquote> <h4 id="hashmap-jdk1-8之前"><a href="#hashmap-jdk1-8之前" class="header-anchor">#</a> HashMap JDK1.8之前</h4> <p>JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。<strong>也就是说创建一个链表数组</strong>，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链中即可。</p> <p><img src="https://s2.loli.net/2022/06/17/rnV7ChIEDc6e89o.png" alt="image-20220617181159573"></p> <h4 id="hashmap-jdk1-8之后"><a href="#hashmap-jdk1-8之后" class="header-anchor">#</a> HashMap JDK1.8之后</h4> <p>相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</p> <p><img src="https://s2.loli.net/2022/06/17/cK1BY9wVFveXDoQ.png" alt="image-20220617181234980"></p> <h4 id="jdk1-7-vs-jdk1-8-比较"><a href="#jdk1-7-vs-jdk1-8-比较" class="header-anchor">#</a> JDK1.7 VS JDK1.8 比较</h4> <p>JDK1.8主要解决或优化了一下问题：</p> <ol><li>resize 扩容优化</li> <li>引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考</li> <li>解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题。</li></ol> <table><thead><tr><th>不同</th> <th>JDK 1.7</th> <th>JDK 1.8</th></tr></thead> <tbody><tr><td>存储结构</td> <td>数组 + 链表</td> <td>数组 + 链表 + 红黑树</td></tr> <tr><td>初始化方式</td> <td>单独函数： inflateTable()</td> <td>直接集成到了扩容函数resize() 中</td></tr> <tr><td>hash值计算方式</td> <td>扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算</td> <td>扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算</td></tr> <tr><td>存放数据的规则</td> <td>无冲突时，存放数组；冲突时，存放链表</td> <td>无冲突时，存放数组；冲突 &amp; 链表长度 &lt;8：存放单链表；冲突 &amp; 链表长度 &gt; 8：树化并存放红黑树</td></tr> <tr><td>插入数据方式</td> <td>头插法（先讲原位置的数据移到后1位，再插入数据到该位置）</td> <td>尾插法（直接插入到链表尾部/红黑树）</td></tr> <tr><td>扩容后存储位置的计算方式</td> <td>全部按照原来方法进行计算（即hashCode -&gt;&gt; 扰动函数 -&gt;&gt; (h&amp;length-1)）</td> <td>按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量）</td></tr></tbody></table> <h3 id="什么是红黑树"><a href="#什么是红黑树" class="header-anchor">#</a> 什么是红黑树</h3> <h4 id="说到红黑树先讲什么是二叉树"><a href="#说到红黑树先讲什么是二叉树" class="header-anchor">#</a> 说到红黑树先讲什么是二叉树</h4> <p>二叉树简单来说就是每一个节上可以关联俩个子节点</p> <div class="language-tex line-numbers-mode"><pre class="language-tex"><code>大概就是这样子：
      a
  / 	  <span class="token function selector">\
</span> b 		   c
/ <span class="token function selector">\ </span>      / <span class="token function selector">\
</span>d    e   f   g
/ <span class="token function selector">\ </span>/ <span class="token function selector">\ </span>/ <span class="token function selector">\ </span>/ <span class="token function selector">\
</span>h i j k l m n o
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="红黑树"><a href="#红黑树" class="header-anchor">#</a> 红黑树</h3> <ul><li>红黑树是一种特殊的二叉查找树。红黑树的每个结点上都有存储位表示结点的颜色，可以是红(Red)或黑(Black)。</li> <li>红黑树的每个结点是黑色或者红色。当是不管怎么样他的根结点是黑色。每个叶子结点（叶子结点代表终结、结尾的节点）也是黑色 [<code>注意：这里叶子结点，是指为空(NIL或NULL)的叶子结点！</code>]。</li> <li>如果一个结点是红色的，则它的子结点必须是黑色的。</li> <li>每个结点到叶子结点NILL所经过的黑色结点的个数一样的。[确保没有一条路径会比其他路径长出俩倍，所以红黑树是相对接近平衡的二叉树的！]</li> <li>红黑树的基本操作是添加、删除。在对红黑树进行添加或删除之后，都会用到旋转方法。为什么呢？道理很简单，添加或删除红黑树中的结点之后，红黑树的结构就发生了变化，可能不满足上面三条性质，也就不再是一颗红黑树了，而是一颗普通的树。而通过旋转和变色，可以使这颗树重新成为红黑树。简单点说，旋转和变色的目的是让树保持红黑树的特性。</li></ul> <h3 id="hashmap的put方法的具体流程"><a href="#hashmap的put方法的具体流程" class="header-anchor">#</a> HashMap的put方法的具体流程？</h3> <ul><li><p>当我们put的时候，首先计算 <code>key</code> 的<code>hash</code> 值，这里调用了 <code>hash</code> 方法， <code>hash</code> 方法实际是让<code>key.hashCode()</code> 与<code>key.hashCode()&gt;&gt;&gt;16</code> 进行异或操作，高16bit补0，一个数和0异或不变，所以 hash 函数大概的作用就是：<strong>高16bit不变，低16bit和高16bit做了一个异或，目的是减少碰撞</strong>。按照函数注释，因为bucket数组大小是2的幂，计算下标index = (table.length - 1) &amp;hash ，如果不做 hash 处理，相当于散列生效的只有几个低 bit 位，为了减少散列的碰撞，设计者综合考虑了速度、作用、质量之后，使用高16bit和低16bit异或来简单处理减少碰撞，而且JDK8中用了复杂度 O（logn）的树结构来提升碰撞下的性能。</p></li> <li><h4 id="putval方法执行流程图"><a href="#putval方法执行流程图" class="header-anchor">#</a> putVal方法执行流程图</h4></li></ul> <p><img src="https://s2.loli.net/2022/06/20/Ck1rGpF9YSywcBx.png" alt="image-20220620201620869"></p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token class-name">V</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">int</span> h<span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//实现Map.put和相关方法</span>
<span class="token keyword">final</span> <span class="token class-name">V</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> <span class="token class-name">K</span> key<span class="token punctuation">,</span> <span class="token class-name">V</span> value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span>
<span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> p<span class="token punctuation">;</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
<span class="token comment">// 步骤①：tab为空则创建</span>
<span class="token comment">// table未初始化或者长度为0，进行扩容</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token comment">// 步骤②：计算index，并对null做处理</span>
<span class="token comment">// (n - 1) &amp; hash 确定元素存放在哪个桶中，桶为空，新生成结点放入桶中(此时，这个结点是放在数</span>
组中<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 桶中已经存在元素</span>
<span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span> <span class="token class-name">K</span> k<span class="token punctuation">;</span>
<span class="token comment">// 步骤③：节点key存在，直接覆盖value</span>
<span class="token comment">// 比较桶中第一个元素(数组中的结点)的hash值相等，key相等</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 将第一个元素赋值给e，用e来记录</span>
e <span class="token operator">=</span> p<span class="token punctuation">;</span>
<span class="token comment">// 步骤④：判断该链为红黑树</span>
<span class="token comment">// hash值不相等，即key不相等；为红黑树结点</span>
<span class="token comment">// 如果当前元素类型为TreeNode，表示为红黑树，putTreeVal返回待存放的node, e可能为null</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
<span class="token comment">// 放入树中</span>
e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 步骤⑤：该链为链表</span>
<span class="token comment">// 为链表结点</span>
<span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token comment">// 在链表最末插入结点</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 到达链表的尾部</span>
<span class="token comment">//判断该链表尾部指针是不是空的</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 在尾部插入新结点</span>
p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//判断链表的长度是否达到转化红黑树的临界值，临界值为8</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">&gt;=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// -1 for 1st</span>
<span class="token comment">//链表结构转树形结构</span>
<span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 跳出循环</span>
<span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 判断链表中结点的key值与插入的元素的key值是否相等</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 相等，跳出循环</span>
<span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token comment">// 用于遍历桶中的链表，与前面的e = p.next组合，可以遍历链表</span>
p <span class="token operator">=</span> e<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//判断当前的key已经存在的情况下，再来一个相同的hash值、key值时，返回新来的value这个</span>
值
<span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 记录e的value</span>
<span class="token class-name">V</span> oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
<span class="token comment">// onlyIfAbsent为false或者旧值为null</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token comment">//用新值替换旧值</span>
e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
<span class="token comment">// 访问后回调</span>
<span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 返回旧值</span>
<span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 结构性修改</span>
<span class="token operator">++</span>modCount<span class="token punctuation">;</span>
<span class="token comment">// 步骤⑥：超过最大容量就扩容</span>
<span class="token comment">// 实际大小大于阈值则扩容</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">&gt;</span> threshold<span class="token punctuation">)</span>
<span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 插入后回调</span>
<span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br></div></div><ol><li>判断键值对数组table[i]是否为空或为null，否则执行resize()进行扩容；</li> <li>根据键值key计算hash值得到插入的数组索引i，如果table[i]==null，直接新建节点添加，转向
⑥，如果table[i]不为空，转向③；</li> <li>判断table[i]的首个元素是否和key一样，如果相同直接覆盖value，否则转向④，这里的相同指的
是hashCode以及equals；</li> <li>判断table[i] 是否为treeNode，即table[i] 是否是红黑树，如果是红黑树，则直接在树中插入键值
对，否则转向5；</li> <li>遍历table[i]，判断链表长度是否大于8，大于8的话把链表转换为红黑树，在红黑树中执行插入操
作，否则进行链表的插入操作；遍历过程中若发现key已经存在直接覆盖value即可；</li> <li>插入成功后，判断实际存在的键值对数量size是否超多了最大容量threshold，如果超过，进行扩
容。</li></ol> <h3 id="hashmap的扩容操作是怎么实现的"><a href="#hashmap的扩容操作是怎么实现的" class="header-anchor">#</a> HashMap的扩容操作是怎么实现的？</h3> <ol><li><p>在jdk1.8中，resize方法是在hashmap中的键值对大于阀值时或者初始化时，就调用resize方法进行扩容；</p></li> <li><p>每次扩展的时候，都是扩展2倍；</p></li> <li><p>扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置。在putVal()中，我们看到在这个函数里面使用到了2次resize()方法，resize()方法表示的在进行第一次初始化时会对其进行扩容，或者当该数组的实际大小大于其临界值值(第一次为12),这个时候在扩容的同时也会伴随的桶上面的元素进行重新分发，这也是JDK1.8版本的一个优化的地方，在1.7中，扩容之后需要重新去计算其Hash值，根据Hash值对其进行分发，但在1.8版本中，则是根据在同一个桶的位置中进行判断(e.hash &amp; oldCap)是否为0，重新进行hash分配后，该元素的位置要么停留在原始位置，要么移动到原始位置+增加的数组大小这个位置上</p></li></ol> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span><span class="token comment">//oldTab指向hash桶数组</span>
<span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
<span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>
<span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果oldCap不为空的话，就是hash桶数组不为空</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">&gt;=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//如果大于最大容量了，就赋值为整数最大的阀值</span>
threshold <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>
<span class="token keyword">return</span> oldTab<span class="token punctuation">;</span><span class="token comment">//返回</span>
<span class="token punctuation">}</span><span class="token comment">//如果当前hash桶数组的长度在扩容后仍然小于最大容量 并且oldCap大于默认值16</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>
oldCap <span class="token operator">&gt;=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>
newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment">// double threshold 双倍扩容阀值threshold</span>
<span class="token punctuation">}</span>
<span class="token comment">// 旧的容量为0，但threshold大于零，代表有参构造有cap传入，threshold已经被初始化</span>
成最小<span class="token number">2</span>的n次幂
<span class="token comment">// 直接将该值赋给新的容量</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// initial capacity was placed in threshold</span>
newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>
<span class="token comment">// 无参构造创建的map，给出默认容量和threshold 16, 16*0.75</span>
<span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// zero initial threshold signifies using</span>
defaults
newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>
newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 新的threshold = 新的cap * 0.75</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>
newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span>
<span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span>MAXIMUM_CAPACITY <span class="token operator">?</span>
<span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>ft <span class="token operator">:</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>
<span class="token comment">// 计算出新的数组长度后赋给当前成员变量table</span>
<span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">&quot;rawtypes&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;unchecked&quot;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//新建hash桶数组</span>
table <span class="token operator">=</span> newTab<span class="token punctuation">;</span><span class="token comment">//将新数组的值复制给旧的hash桶数组</span>
<span class="token comment">// 如果原先的数组没有初始化，那么resize的初始化工作到此结束，否则进入扩容元素重排逻辑，使</span>
其均匀的分散
<span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 遍历新数组的所有桶下标</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token comment">// 旧数组的桶下标赋给临时变量e，并且解除旧数组中的引用，否则就数组无</span>
法被GC回收
oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// 如果e.next==null，代表桶中就一个元素，不存在链表或者红黑树</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token comment">// 用同样的hash映射算法把该元素加入新的数组</span>
newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>
<span class="token comment">// 如果e是TreeNode并且e.next!=null，那么处理树中元素的重排</span>
<span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span>e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// e是链表的头并且e.next!=null，那么处理链表中元素重排</span>
<span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment">// preserve order</span>
<span class="token comment">// loHead,loTail 代表扩容后不用变换下标，见注1</span>
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> loHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> loTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token comment">// hiHead,hiTail 代表扩容后变换下标，见注1</span>
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> hiHead <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">,</span> hiTail <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> next<span class="token punctuation">;</span>
<span class="token comment">// 遍历链表</span>
<span class="token keyword">do</span> <span class="token punctuation">{</span>
next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token comment">// 初始化head指向链表当前元素e，e不一定是链表的</span>
第一个元素，初始化后loHead
<span class="token comment">// 代表下标保持不变的链表的头元素</span>
loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
<span class="token keyword">else</span>
<span class="token comment">// loTail.next指向当前e</span>
loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
<span class="token comment">// loTail指向当前的元素e</span>
<span class="token comment">// 初始化后，loTail和loHead指向相同的内存，所以当</span>
loTail<span class="token punctuation">.</span>next指向下一个元素时，
<span class="token comment">// 底层数组中的元素的next引用也相应发生变化，造成lowHead.next.next.....</span>
<span class="token comment">// 跟随loTail同步，使得lowHead可以链接到所有属于该链</span>
表的元素。
loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">else</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
<span class="token comment">// 初始化head指向链表当前元素e, 初始化后hiHead</span>
代表下标更改的链表头元素
hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>
<span class="token keyword">else</span>
hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>
hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 遍历结束, 将tail指向null，并把链表头放入新数组的相应下标，</span>
形成新的映射。
<span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">return</span> newTab<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br><span class="line-number">84</span><br><span class="line-number">85</span><br><span class="line-number">86</span><br><span class="line-number">87</span><br><span class="line-number">88</span><br><span class="line-number">89</span><br><span class="line-number">90</span><br><span class="line-number">91</span><br><span class="line-number">92</span><br><span class="line-number">93</span><br><span class="line-number">94</span><br><span class="line-number">95</span><br><span class="line-number">96</span><br><span class="line-number">97</span><br><span class="line-number">98</span><br><span class="line-number">99</span><br><span class="line-number">100</span><br><span class="line-number">101</span><br><span class="line-number">102</span><br><span class="line-number">103</span><br><span class="line-number">104</span><br><span class="line-number">105</span><br><span class="line-number">106</span><br><span class="line-number">107</span><br><span class="line-number">108</span><br></div></div><h3 id="hashmap是怎么解决哈希冲突的"><a href="#hashmap是怎么解决哈希冲突的" class="header-anchor">#</a> HashMap是怎么解决哈希冲突的？</h3> <p>答：在解决这个问题之前，我们首先需要知道什么是哈希冲突，而在了解哈希冲突之前我们还要知道什么是哈希才行；</p> <h4 id="什么是哈希"><a href="#什么是哈希" class="header-anchor">#</a> 什么是哈希？</h4> <p>Hash，一般翻译为“散列”，也有直接音译为“哈希”的， Hash就是指使用哈希算法是指把任意长度的二进制映射为固定长度的较小的二进制值，这个较小的二进制值叫做哈希值。</p> <h4 id="什么是哈希冲突"><a href="#什么是哈希冲突" class="header-anchor">#</a> 什么是哈希冲突？</h4> <ul><li>当两个不同的输入值，根据同一散列函数计算出相同的散列值的现象，我们就把它叫做碰撞（哈希碰撞）。</li></ul> <h4 id="hashmap的数据结构"><a href="#hashmap的数据结构" class="header-anchor">#</a> HashMap的数据结构</h4> <p>HashMap的数据结构
在Java中，保存数据有两种比较简单的数据结构：<strong>数组和链表</strong>。
<strong>数组的特点是：寻址容易，插入和删除困难；</strong> <strong>链表的特点是：寻址困难，但插入和删除容易；</strong></p> <ul><li><p>所以我们将数组和链表结合在一起，发挥两者各自的优势，就可以使用俩种方式：链地址法和开放地址法可以解决哈希冲突：</p> <p><img src="https://s2.loli.net/2022/06/20/pWJubUewAPcj2vF.png" alt="image-20220620204017419"></p></li> <li><p>链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；</p></li> <li><p>开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</p></li> <li><p>但相比于hashCode返回的int类型，我们HashMap初始的容量大小DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4 （即2的四次方16）要远小于int类型的范围，所以我们如果只是单纯的用hashCode取余来获取对应的bucket这将会大大增加哈希碰撞的概率，并且最坏情况下还会将HashMap变成一个单链表，所以我们还需要对hashCode作一定的优化</p></li></ul> <h4 id="hash-函数"><a href="#hash-函数" class="header-anchor">#</a> hash()函数</h4> <p>上面提到的问题，主要是因为如果使用hashCode取余，那么相当于参与运算的只有hashCode的低位，高位是没有起到任何作用的，所以我们的思路就是让hashCode取值出的高位也参与运算，进一步降低hash碰撞的概率，使得数据分布更平均，我们把这样的操作称为扰动，在JDK 1.8中的hash()函数如下：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hash</span><span class="token punctuation">(</span><span class="token class-name">Object</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">int</span> h<span class="token punctuation">;</span>
<span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token punctuation">(</span>h <span class="token operator">=</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>h <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 与自己</span>
右移<span class="token number">16</span>位进行异或运算（高低位异或）
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>这比在JDK 1.7中，更为简洁，相比在1.7中的4次位运算，5次异或运算（9次扰动），在1.8中，只进行了1次位运算和1次异或运算（2次扰动）；</p> <h3 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h3> <ul><li>简单总结一下HashMap是使用了哪些方法来有效解决哈希冲突的：
<ul><li>链表法就是将相同hash值的对象组织成一个链表放在hash值对应的槽位；</li> <li>开放地址法是通过一个探测算法，当某个槽位已经被占据的情况下继续查找下一个可以使用的槽位。</li></ul></li></ul> <h4 id="能否使用任何类作为-map-的-key"><a href="#能否使用任何类作为-map-的-key" class="header-anchor">#</a> 能否使用任何类作为 Map 的 key？</h4> <p>可以使用任何类作为 Map 的 key，然而在使用之前，需要考虑以下几点：</p> <ul><li>如果类重写了 equals() 方法，也应该重写 hashCode() 方法。</li> <li>类的所有实例需要遵循与 equals() 和 hashCode() 相关的规则。</li> <li>如果一个类没有使用 equals()，不应该在 hashCode() 中使用它。</li> <li>用户自定义 Key 类最佳实践是使之为不可变的，这样 hashCode() 值可以被缓存起来，拥有更好的性能。不可变的类也可以确保 hashCode() 和 equals() 在未来不会改变，这样就会解决与可变相关的问题了。</li></ul> <h4 id="为什么hashmap中string、integer这样的包装类适合作为k"><a href="#为什么hashmap中string、integer这样的包装类适合作为k" class="header-anchor">#</a> 为什么HashMap中String、Integer这样的包装类适合作为K？</h4> <p>答：String、Integer等包装类的特性能够保证Hash值的不可更改性和计算准确性，能够有效的减少Hash碰撞的几率</p> <ul><li>都是final类型，即不可变性，保证key的不可更改性，不会存在获取hash值不同的情况</li> <li>内部已重写了equals() 、hashCode() 等方法，遵守了HashMap内部的规范（不清楚可以去上面看看putValue的过程），不容易出现Hash值计算错误的情况；</li></ul> <h4 id="如果使用object作为hashmap的key-应该怎么办呢"><a href="#如果使用object作为hashmap的key-应该怎么办呢" class="header-anchor">#</a> 如果使用Object作为HashMap的Key，应该怎么办呢？</h4> <p>答：重写hashCode() 和equals() 方法</p> <ol><li><strong>重写hashCode() 是因为需要计算存储数据的存储位置</strong>，需要注意不要试图从散列码计算中
排除掉一个对象的关键部分来提高性能，这样虽然能更快但可能会导致更多的Hash碰撞；</li> <li><strong>重写equals() 方法</strong>，需要遵守自反性、对称性、传递性、一致性以及对于任何非null的引用
值x，x.equals(null)必须返回false的这几个特性，目的是为了保证key在哈希表中的唯一性；</li></ol> <h4 id="hashmap为什么不直接使用hashcode-处理后的哈希值直接作为table的下标"><a href="#hashmap为什么不直接使用hashcode-处理后的哈希值直接作为table的下标" class="header-anchor">#</a> HashMap为什么不直接使用hashCode()处理后的哈希值直接作为table的下标？</h4> <ul><li>答： hashCode() 方法返回的是int整数类型，其范围为-(2 ^ 31)~(2 ^ 31 - 1)，约有40亿个映射空间，而HashMap的容量范围是在16（初始化默认值）~2 ^ 30，HashMap通常情况下是取不到最大值的，并且设备上也难以提供这么多的存储空间，从而导致通过hashCode() 计算出的哈希值可能不在数组大小范围内，进而无法匹配存储位置；</li> <li>那怎么解决呢？
<ol><li>HashMap自己实现了自己的hash() 方法，通过两次扰动使得它自己的哈希值高低位自行进
行异或运算，降低哈希碰撞概率也使得数据分布更平均；</li> <li>在保证数组长度为2的幂次方的时候，使用hash() 运算之后的值与运算（&amp;）（数组长度 -
1）来获取数组下标的方式进行存储，这样一来是比取余操作更加有效率，二来也是因为只有
当数组长度为2的幂次方时，h&amp;(length-1)才等价于h%length，三来解决了“哈希值与数组大
小范围不匹配”的问题；</li></ol></li></ul> <h4 id="hashmap-的长度为什么是2的幂次方"><a href="#hashmap-的长度为什么是2的幂次方" class="header-anchor">#</a> HashMap 的长度为什么是2的幂次方</h4> <ul><li><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀，每个链表/红黑树长度大致相同。这个实现就是把数据存到哪个链表/红黑树中的算法。</p></li> <li><h4 id="这个算法应该如何设计呢"><a href="#这个算法应该如何设计呢" class="header-anchor">#</a> 这个算法应该如何设计呢？</h4> <ul><li>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。” 并且 采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</li></ul></li> <li><h4 id="那为什么是两次扰动呢"><a href="#那为什么是两次扰动呢" class="header-anchor">#</a> 那为什么是两次扰动呢？</h4> <ul><li>答：这样就是加大哈希值低位的随机性，使得分布更均匀，从而提高对应数组存储下标位置的随机性&amp;均匀性，最终减少Hash冲突，两次就够了，已经达到了高位低位同时参与运算的目的；</li></ul></li></ul> <h3 id="hashmap-与-hashtable-有什么区别"><a href="#hashmap-与-hashtable-有什么区别" class="header-anchor">#</a> HashMap 与 HashTable 有什么区别？</h3> <ol><li>线程安全： HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过 synchronized 修饰。（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</li> <li>效率： 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；（如果你要保证线程安全的话就使用 ConcurrentHashMap ）；</li> <li>对Null key 和Null value的支持： HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛NullPointerException。</li> <li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong></li> <li>创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。</li> <li>创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小。也就是说 HashMap 总是使用2的幂作为哈希表的大小，后面会介绍到为什么是2的幂次方。</li> <li>底层数据结构： JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li> <li>推荐使用：在 Hashtable 的类注释可以看到，Hashtable 是保留类不建议使用，推荐在单线程环境下使用 HashMap 替代，<strong>如果需要多线程使用则用 ConcurrentHashMap 替代</strong>。</li></ol> <h2 id="什么是treemap-简介"><a href="#什么是treemap-简介" class="header-anchor">#</a> 什么是TreeMap 简介</h2> <ul><li>TreeMap 是一个有序的key-value集合，它是通过红黑树实现的。</li> <li>TreeMap基于红黑树（Red-Black tree）实现。该映射根据其键的自然顺序进行排序，或者根据创建映射时提供的 Comparator 进行排序，具体取决于使用的构造方法。</li> <li>TreeMap是线程非同步的。</li></ul> <p>如何决定使用 HashMap 还是 TreeMap？
对于在Map中插入、删除和定位元素这类操作，HashMap是最好的选择。然而，假如你需要对一个有序的key集合进行遍历，TreeMap是更好的选择。基于你的collection的大小，也许向HashMap中添加元素会更快，将map换为TreeMap进行有序key的遍历。</p> <h2 id="hashmap-和-concurrenthashmap-的区别"><a href="#hashmap-和-concurrenthashmap-的区别" class="header-anchor">#</a> HashMap 和 ConcurrentHashMap 的区别</h2> <ol><li>ConcurrentHashMap对整个桶数组进行了分割分段(Segment)，然后在每一个分段上都用lock锁进行保护，相对于HashTable的synchronized锁的粒度更精细了一些，并发性能更好，而HashMap没有锁机制，不是线程安全的。（JDK1.8之后ConcurrentHashMap启用了一种全新的方式实现,利用CAS算法。）</li> <li>HashMap的键值对允许有null，但是ConCurrentHashMap都不允许。</li></ol> <h2 id="concurrenthashmap-和-hashtable-的区别"><a href="#concurrenthashmap-和-hashtable-的区别" class="header-anchor">#</a> ConcurrentHashMap 和 Hashtable 的区别？</h2> <ul><li><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p> <ul><li>底层数据结构： JDK1.7的 ConcurrentHashMap 底层采用 分段的数组+链表 实现，JDK1.8采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8之前的 HashMap 的底层数据结构类似都是采用 数组+链表 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li> <li>实现线程安全的方式：</li></ul></li> <li><p>在JDK1.7的时候，<strong>ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。（默认分配16个Segment，比Hashtable效率提高16倍。） 到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对synchronized锁做了很多优化） 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；</p></li> <li><p>② Hashtable(同一把锁) :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</p></li> <li><p>两者的对比图：</p></li></ul> <ol><li><strong>HashTable:</strong></li></ol> <p><img src="https://s2.loli.net/2022/06/20/YVeMJtxaEkWZKHF.png" alt="image-20220620211030948"></p> <ol start="2"><li><strong>JDK1.7的ConcurrentHashMap：</strong></li></ol> <p><img src="https://s2.loli.net/2022/06/20/BrKlvgHzkY32hMI.png" alt="image-20220620211129653"></p> <ol start="3"><li><strong>JDK1.8的ConcurrentHashMap（TreeBin: 红黑二叉树节点 Node: 链表节点）：</strong></li></ol> <p><img src="https://s2.loli.net/2022/06/20/T3hK5OBZHVWukpF.png" alt="image-20220620211207240"></p> <ul><li>答：ConcurrentHashMap 结合了 HashMap 和 HashTable 二者的优势。HashMap 没有考虑同步，HashTable 考虑了同步的问题使用了synchronized 关键字，所以 HashTable 在每次同步执行时都要锁住整个结构。 ConcurrentHashMap 锁的方式是稍微细粒度的。</li></ul> <h2 id="concurrenthashmap-底层具体实现知道吗-实现原理是什么"><a href="#concurrenthashmap-底层具体实现知道吗-实现原理是什么" class="header-anchor">#</a> ConcurrentHashMap 底层具体实现知道吗？实现原理是什么？</h2> <h3 id="jdk1-7"><a href="#jdk1-7" class="header-anchor">#</a> JDK1.7</h3> <p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。
在JDK1.7中，ConcurrentHashMap采用Segment + HashEntry的方式进行实现，结构如下：一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p> <p><img src="https://s2.loli.net/2022/06/20/Bd1UVTfyQreXaqL.png" alt="image-20220620211342160"></p> <ol><li>该类包含两个静态内部类 HashEntry 和 Segment ；前者用来封装映射表的键值对，后者用来充当锁的角色；</li> <li>Segment 是一种可重入的锁 ReentrantLock，每个 Segment 守护一个HashEntry 数组里得元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment 锁。</li></ol> <h3 id="jdk1-8"><a href="#jdk1-8" class="header-anchor">#</a> JDK1.8</h3> <p>在JDK1.8中，放弃了Segment臃肿的设计，取而代之的是采用Node + CAS + Synchronized来保证并发安全进行实现，synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。
结构如下：</p> <p><img src="https://s2.loli.net/2022/06/20/uFYRNQwx1g3rqyP.png" alt="image-20220620211506654"></p> <ul><li><strong>附加源码，有需要的可以看看</strong></li> <li>插入元素过程（建议去看看源码）：</li> <li>如果相应位置的Node还没有初始化，则调用CAS插入相应的数据；</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>f <span class="token operator">=</span> <span class="token function">tabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">casTabAt</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token keyword">break</span><span class="token punctuation">;</span> <span class="token comment">// no lock when adding to empty bin</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>如果相应位置的Node不为空，且当前该节点不处于移动状态，则对该节点加synchronized锁，如果该节点的hash不小于0，则遍历链表更新节点或插入新节点；</li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">if</span> <span class="token punctuation">(</span>fh <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
binCount <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> e <span class="token operator">=</span> f<span class="token punctuation">;</span><span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token class-name">K</span> ek<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span>ek <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span>
<span class="token punctuation">(</span>ek <span class="token operator">!=</span> <span class="token keyword">null</span> <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>ek<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
oldVal <span class="token operator">=</span> e<span class="token punctuation">.</span>val<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent<span class="token punctuation">)</span>
e<span class="token punctuation">.</span>val <span class="token operator">=</span> value<span class="token punctuation">;</span>
<span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span> pred <span class="token operator">=</span> e<span class="token punctuation">;</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
pred<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">K</span><span class="token punctuation">,</span><span class="token class-name">V</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><ol><li><p>如果该节点是TreeBin类型的节点，说明是红黑树结构，则通过putTreeVal方法往红黑树中插入节点；如果binCount不为0，说明put操作对数据产生了影响，如果当前链表的个数达到8个，则通过treeifyBin方法转化为红黑树，如果oldVal不为空，说明是一次更新操作，没有对元素个数产生影响，则直接返回旧值；</p></li> <li><p>如果插入的是一个新节点，则执行addCount()方法尝试更新元素个数baseCount；</p></li></ol> <h2 id="辅助工具类"><a href="#辅助工具类" class="header-anchor">#</a> 辅助工具类</h2> <h3 id="array-和-arraylist-有何区别"><a href="#array-和-arraylist-有何区别" class="header-anchor">#</a> Array 和 ArrayList 有何区别？</h3> <ul><li><p>Array 可以存储基本数据类型和对象，ArrayList 只能存储对象。</p></li> <li><p>Array 是指定固定大小的，而 ArrayList 大小是自动扩展的。</p></li> <li><p>Array 内置方法没有 ArrayList 多，比如 addAll、removeAll、iteration 等方法只有 ArrayList有。</p> <blockquote><p>对于基本类型数据，集合使用自动装箱来减少编码工作量。但是，当处理固定大小的基本数据类型的时候，这种方式相对比较慢。</p></blockquote></li></ul> <h3 id="comparable-和-comparator的区别"><a href="#comparable-和-comparator的区别" class="header-anchor">#</a> comparable 和 comparator的区别？</h3> <ul><li>comparable接口实际上是出自java.lang包，它有一个 compareTo(Object obj)方法用来排序</li> <li>comparator接口实际上是出自 java.util 包，它有一个compare(Object obj1, Object obj2)方法用来排序一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo方法或compare方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的Collections.sort().</li></ul> <h3 id="collection-和-collections-有什么区别"><a href="#collection-和-collections-有什么区别" class="header-anchor">#</a> Collection 和 Collections 有什么区别？</h3> <p>java.util.Collection 是一个集合接口（集合类的一个顶级接口）。它提供了对集合对象进行基本操作的通用接口方法。Collection接口在Java 类库中有很多具体的实现。Collection接口的意义是为各种具体的集合提供了最大化的统一操作方式，其直接继承接口有List与Set。Collections则是集合类的一个工具类/帮助类，其中提供了一系列静态方法，用于对集合中元素进行排序、搜索以及线程安全等各种操作。</p> <h3 id="treemap-和-treeset-在排序时如何比较元素-collections-工具类中的-sort-方法如何比较元素"><a href="#treemap-和-treeset-在排序时如何比较元素-collections-工具类中的-sort-方法如何比较元素" class="header-anchor">#</a> TreeMap 和 TreeSet 在排序时如何比较元素？Collections 工具类中的 sort()方法如何比较元素？</h3> <ul><li>TreeSet 要求存放的对象所属的类必须实现 Comparable 接口，该接口提供了比较元素的compareTo()方法，当插入元素时会回调该方法比较元素的大小。TreeMap 要求存放的键值对映射的键必须实现 Comparable 接口从而根据键对元素进 行排 序。</li> <li>Collections 工具类的 sort 方法有两种重载的形式，</li> <li>第一种要求传入的待排序容器中存放的对象比较实现 Comparable 接口以实现元素的比较；</li></ul></div></div> <div class="page-slot page-slot-bottom"><!-- 横向自适应 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6620245489"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/vicxsl/vicxsl.github.io/edit/master/docs/Java面试宝典/01.Java快速面试/01.Java集合容器面试题.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2022/06/23, 01:56:34</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/572e34/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">Java基础知识面试题</div></a> <a href="/pages/bb678c/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">并发编程面试题</div></a></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/572e34/" class="prev">Java基础知识面试题</a></span> <span class="next"><a href="/pages/bb678c/">并发编程面试题</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/1046c9/"><div>万字长文：选 Redis 还是 MQ，终于说明白了！</div></a> <span>10-11</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/acfcf1/"><div>Typora+gitee+自定义命令实现图床</div></a> <span>09-13</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/9b877b/"><div>字节终面：两个文件的公共url怎么找？</div></a> <span>09-09</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:vicxsl@163.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/vicxsl" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="http://music.163.com/playlist?id=2424753600" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://doc.xugaoyi.com/" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2019-2022
    <span>Vic | <a href="https://github.com/xugaoyi/vuepress-theme-vdoing/blob/master/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <div class="body-bg" style="background:url() center center / cover no-repeat;opacity:0.5;"></div> <!----> <div class="custom-html-window custom-html-window-rb" style="display:;"><div class="custom-wrapper"><i class="close-but">×</i> <div><!-- 固定160*160px -->
      <ins class="adsbygoogle"
          style="display:inline-block;max-width:160px;max-height:160px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="8377369658"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      </div></div></div></div><div class="global-ui"><div></div><APlayer audio="" fixed="true" theme="#b7daff" loop="loop" order="list" preload="auto" volume="0.7" mutex="true" lrc-type="0" list-max-height="250" storage-name="vuepress-plugin-meting" id="aplayer-fixed"></APlayer></div></div>
    <script src="/assets/js/app.646a5a8b.js" defer></script><script src="/assets/js/2.18e0a64f.js" defer></script><script src="/assets/js/3.cb3603b5.js" defer></script><script src="/assets/js/123.9a3fac58.js" defer></script>
  </body>
</html>