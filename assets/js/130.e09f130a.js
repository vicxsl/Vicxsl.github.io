(window.webpackJsonp=window.webpackJsonp||[]).push([[130],{658:function(r,t,a){"use strict";a.r(t);var i=a(16),s=Object(i.a)({},(function(){var r=this,t=r.$createElement,a=r._self._c||t;return a("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[a("h1",{attrs:{id:"什么是微服务架构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是微服务架构"}},[r._v("#")]),r._v(" 什么是微服务架构")]),r._v(" "),a("p",[r._v("微服务架构就是将单体的应用程序分成多个应用程序，这多个应用程序就成为微服务，每个微服务运行在自己的进程中，并使用轻量级的机制通信。这些服务围绕业务能力来划分，并通过自动化部署机制来独立部署。这些服务可以使用不同的编程语言，不同数据库，以保证最低限度的集中式管理。")]),r._v(" "),a("h1",{attrs:{id:"为什么需要学习spring-cloud"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么需要学习spring-cloud"}},[r._v("#")]),r._v(" 为什么需要学习Spring Cloud")]),r._v(" "),a("p",[r._v("不论是商业应用还是用户应用，在业务初期都很简单，我们通常会把它实现为单体结构的应用。但是，随着业务逐渐发展，产品思想会变得越来越复杂，单体结构的应用也会越来越复杂。这就会给应用带来如下的几个问题：")]),r._v(" "),a("ul",[a("li",[r._v("代码结构混乱：业务复杂，导致代码量很大，管理会越来越困难。同时，这也会给业务的快速迭代带来巨大挑战；")]),r._v(" "),a("li",[r._v("开发效率变低：开发人员同时开发一套代码，很难避免代码冲突。开发过程会伴随着不断解决冲突的过程，这会严重的影响开发效率；")]),r._v(" "),a("li",[r._v("排查解决问题成本高：线上业务发现 bug，修复 bug 的过程可能很简单。但是，由于只有一套代码，需要重新编译、打包、上线，成本很高。")])]),r._v(" "),a("p",[r._v("由于单体结构的应用随着系统复杂度的增高，会暴露出各种各样的问题。近些年来，微服务架构逐渐取代了单体架构，且这种趋势将会越来越流行。Spring Cloud是目前最常用的微服务开发框架，已经在企业级开发中大量的应用。")]),r._v(" "),a("h1",{attrs:{id:"什么是spring-cloud"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是spring-cloud"}},[r._v("#")]),r._v(" 什么是Spring Cloud")]),r._v(" "),a("p",[r._v("Spring Cloud是一系列框架的有序集合。它利用Spring Boot的开发便利性巧妙地"),a("strong",[r._v("简化了分布式系统基础设施的开发")]),r._v("，如"),a("strong",[r._v("服务发现注册、配置中心、智能路由、消息总线、负载均衡、断路器、数据监控等")]),r._v("，都可以用Spring Boot的开发风格做到"),a("strong",[r._v("一键启动和部署")]),r._v("。Spring Cloud并没有重复制造轮子，它只是将各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过Spring Boot风格进行再封装屏蔽掉了复杂的配置和实现原理，最终给开发者留出了一套简单易懂、易部署和易维护的"),a("strong",[r._v("分布式系统")]),r._v("开发工具包。")]),r._v(" "),a("h1",{attrs:{id:"设计目标与优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计目标与优缺点"}},[r._v("#")]),r._v(" 设计目标与优缺点")]),r._v(" "),a("h2",{attrs:{id:"设计目标"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#设计目标"}},[r._v("#")]),r._v(" 设计目标")]),r._v(" "),a("p",[r._v("协调各个微服务，简化分布式系统开发。")]),r._v(" "),a("h2",{attrs:{id:"优缺点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#优缺点"}},[r._v("#")]),r._v(" 优缺点")]),r._v(" "),a("p",[r._v("微服务的框架那么多比如：dubbo、Kubernetes，为什么就要使用Spring Cloud的呢？")]),r._v(" "),a("p",[a("strong",[r._v("优点")]),r._v("：")]),r._v(" "),a("ul",[a("li",[r._v("产出于Spring大家族，Spring在企业级开发框架中无人能敌，来头很大，可以保证后续的更新、完善")]),r._v(" "),a("li",[r._v("组件丰富，功能齐全。Spring Cloud 为微服务架构提供了非常完整的支持。例如、配置管理、服务发现、断路器、微服务网关等；")]),r._v(" "),a("li",[r._v("Spring Cloud 社区活跃度很高，教程很丰富，遇到问题很容易找到解决方案")]),r._v(" "),a("li",[r._v("服务拆分粒度更细，耦合度比较低，有利于资源重复利用，有利于提高开发效率")]),r._v(" "),a("li",[r._v("可以更精准的制定优化服务方案，提高系统的可维护性")]),r._v(" "),a("li",[r._v("减轻团队的成本，可以并行开发，不用关注其他人怎么开发，先关注自己的开发")]),r._v(" "),a("li",[r._v("微服务可以是跨平台的，可以用任何一种语言开发")]),r._v(" "),a("li",[r._v("适于互联网时代，产品迭代周期更短")])]),r._v(" "),a("p",[a("strong",[r._v("缺点")]),r._v("：")]),r._v(" "),a("ul",[a("li",[r._v("微服务过多，治理成本高，不利于维护系统")]),r._v(" "),a("li",[r._v("分布式系统开发的成本高（容错，分布式事务等）对团队挑战大")])]),r._v(" "),a("p",[r._v("总的来说优点大过于缺点，目前看来Spring Cloud是一套非常完善的分布式框架，目前很多企业开始用微服务、Spring Cloud的优势是显而易见的。因此对于想研究微服务架构的同学来说，学习Spring Cloud是一个不错的选择。")]),r._v(" "),a("h1",{attrs:{id:"spring-cloud发展前景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud发展前景"}},[r._v("#")]),r._v(" Spring Cloud发展前景")]),r._v(" "),a("p",[r._v("Spring Cloud对于中小型互联网公司来说是一种福音，因为这类公司往往没有实力或者没有足够的资金投入去开发自己的分布式系统基础设施，使用Spring Cloud一站式解决方案能在从容应对业务发展的同时大大减少开发成本。同时，随着近几年微服务架构和Docker容器概念的火爆，也会让Spring Cloud在未来越来越“云”化的软件开发风格中立有一席之地，尤其是在五花八门的分布式解决方案中提供了标准化的、全站式的技术方案，意义可能会堪比当年Servlet规范的诞生，有效推进服务端软件系统技术水平的进步。")]),r._v(" "),a("h1",{attrs:{id:"主要项目"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#主要项目"}},[r._v("#")]),r._v(" 主要项目")]),r._v(" "),a("p",[r._v('Spring Cloud的子项目，大致可分成两类，一类是对现有成熟框架"Spring Boot化"的封装和抽象，也是数量最多的项目；第二类是开发了一部分分布式系统的基础设施的实现，如Spring Cloud Stream扮演的就是kafka, ActiveMQ这样的角色。')]),r._v(" "),a("h1",{attrs:{id:"springcloud由什么组成"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#springcloud由什么组成"}},[r._v("#")]),r._v(" SpringCloud由什么组成")]),r._v(" "),a("p",[r._v("这就有很多了，我讲几个开发中最重要的\nSpring Cloud Eureka：服务注册与发现\nSpring Cloud Zuul：服务网关\nSpring Cloud Ribbon：客户端负载均衡\nSpring Cloud Feign：声明性的Web服务客户端\nSpring Cloud Hystrix：断路器\nSpring Cloud Config：分布式统一配置管理\n等20几个框架，开源一直在更新")]),r._v(" "),a("h2",{attrs:{id:"spring-cloud-config"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-config"}},[r._v("#")]),r._v(" Spring Cloud Config")]),r._v(" "),a("p",[r._v("集中配置管理工具，分布式系统中统一的外部配置管理，默认使用Git来存储配置，可以支持客户端配置的刷新及加密、解密操作。")]),r._v(" "),a("h2",{attrs:{id:"spring-cloud-netflix"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-netflix"}},[r._v("#")]),r._v(" Spring Cloud Netflix")]),r._v(" "),a("p",[r._v("Netflix OSS 开源组件集成，包括Eureka、Hystrix、Ribbon、Feign、Zuul等核心组件。")]),r._v(" "),a("ul",[a("li",[r._v("Eureka：服务治理组件，包括服务端的注册中心和客户端的服务发现机制；")]),r._v(" "),a("li",[r._v("Ribbon：负载均衡的服务调用组件，具有多种负载均衡调用策略；")]),r._v(" "),a("li",[r._v("Hystrix：服务容错组件，实现了断路器模式，为依赖服务的出错和延迟提供了容错能力；")]),r._v(" "),a("li",[r._v("Feign：基于Ribbon和Hystrix的声明式服务调用组件；")]),r._v(" "),a("li",[r._v("Zuul：API网关组件，对请求提供路由及过滤功能。")])]),r._v(" "),a("h2",{attrs:{id:"spring-cloud-bus"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-bus"}},[r._v("#")]),r._v(" Spring Cloud Bus")]),r._v(" "),a("p",[r._v("用于传播集群状态变化的消息总线，使用轻量级消息代理链接分布式系统中的节点，可以用来动态刷新集群中的服务配置。")]),r._v(" "),a("h2",{attrs:{id:"spring-cloud-consul"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-consul"}},[r._v("#")]),r._v(" Spring Cloud Consul")]),r._v(" "),a("p",[r._v("基于Hashicorp Consul的服务治理组件。")]),r._v(" "),a("h2",{attrs:{id:"spring-cloud-security"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-security"}},[r._v("#")]),r._v(" Spring Cloud Security")]),r._v(" "),a("p",[r._v("安全工具包，对Zuul代理中的负载均衡OAuth2客户端及登录认证进行支持。")]),r._v(" "),a("h2",{attrs:{id:"spring-cloud-sleuth"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-sleuth"}},[r._v("#")]),r._v(" Spring Cloud Sleuth")]),r._v(" "),a("p",[r._v("Spring Cloud应用程序的分布式请求链路跟踪，支持使用Zipkin、HTrace和基于日志（例如ELK）的跟踪。")]),r._v(" "),a("h2",{attrs:{id:"spring-cloud-stream"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-stream"}},[r._v("#")]),r._v(" Spring Cloud Stream")]),r._v(" "),a("p",[r._v("轻量级事件驱动微服务框架，可以使用简单的声明式模型来发送及接收消息，主要实现为Apache Kafka及RabbitMQ。")]),r._v(" "),a("h2",{attrs:{id:"spring-cloud-task"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-task"}},[r._v("#")]),r._v(" Spring Cloud Task")]),r._v(" "),a("p",[r._v("用于快速构建短暂、有限数据处理任务的微服务框架，用于向应用中添加功能性和非功能性的特性。")]),r._v(" "),a("h2",{attrs:{id:"spring-cloud-zookeeper"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-zookeeper"}},[r._v("#")]),r._v(" Spring Cloud Zookeeper")]),r._v(" "),a("p",[r._v("基于Apache Zookeeper的服务治理组件。")]),r._v(" "),a("h2",{attrs:{id:"spring-cloud-gateway"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-gateway"}},[r._v("#")]),r._v(" Spring Cloud Gateway")]),r._v(" "),a("p",[r._v("API网关组件，对请求提供路由及过滤功能。")]),r._v(" "),a("h2",{attrs:{id:"spring-cloud-openfeign"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-openfeign"}},[r._v("#")]),r._v(" Spring Cloud OpenFeign")]),r._v(" "),a("p",[r._v("基于Ribbon和Hystrix的声明式服务调用组件，可以动态创建基于Spring MVC注解的接口实现用于服务调用，在Spring Cloud 2.0中已经取代Feign成为了一等公民。")]),r._v(" "),a("h1",{attrs:{id:"spring-cloud的版本关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud的版本关系"}},[r._v("#")]),r._v(" Spring Cloud的版本关系")]),r._v(" "),a("p",[r._v('Spring Cloud是一个由许多子项目组成的综合项目，各子项目有不同的发布节奏。 为了管理Spring Cloud与各子项目的版本依赖关系，发布了一个清单，其中包括了某个Spring Cloud版本对应的子项目版本。 为了避免Spring Cloud版本号与子项目版本号混淆，Spring Cloud版本采用了名称而非版本号的命名，这些版本的名字采用了伦敦地铁站的名字，根据字母表的顺序来对应版本时间顺序，例如Angel是第一个版本，Brixton是第二个版本。 当Spring Cloud的发布内容积累到临界点或者一个重大BUG被解决后，会发布一个"service releases"版本，简称SRX版本，比如Greenwich.SR2就是Spring Cloud发布的Greenwich版本的第2个SRX版本。目前Spring Cloud的最新版本是Hoxton。')]),r._v(" "),a("h2",{attrs:{id:"spring-cloud和springboot版本对应关系"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud和springboot版本对应关系"}},[r._v("#")]),r._v(" Spring Cloud和SpringBoot版本对应关系")]),r._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"center"}},[a("strong",[r._v("Spring Cloud Version")])]),r._v(" "),a("th",{staticStyle:{"text-align":"center"}},[a("strong",[r._v("SpringBoot Version")])])])]),r._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"center"}},[r._v("Hoxton")]),r._v(" "),a("td",{staticStyle:{"text-align":"center"}},[r._v("2.2.x")])]),r._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[r._v("Greenwich")]),r._v(" "),a("td",{staticStyle:{"text-align":"center"}},[r._v("2.1.x")])]),r._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[r._v("Finchley")]),r._v(" "),a("td",{staticStyle:{"text-align":"center"}},[r._v("2.0.x")])]),r._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[r._v("Edgware")]),r._v(" "),a("td",{staticStyle:{"text-align":"center"}},[r._v("1.5.x")])]),r._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"center"}},[r._v("Dalston")]),r._v(" "),a("td",{staticStyle:{"text-align":"center"}},[r._v("1.5.x")])])])]),r._v(" "),a("h1",{attrs:{id:"springboot和springcloud的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#springboot和springcloud的区别"}},[r._v("#")]),r._v(" SpringBoot和SpringCloud的区别？")]),r._v(" "),a("p",[r._v("SpringBoot专注于"),a("strong",[r._v("快速方便的开发单个个体微服务")]),r._v("。")]),r._v(" "),a("p",[r._v("SpringCloud是"),a("strong",[r._v("关注全局的微服务协调整理治理框架")]),r._v("，它将SpringBoot开发的一个个单体微服务整合并管理起来，")]),r._v(" "),a("p",[r._v("为各个微服务之间提供，配置管理、服务发现、断路器、路由、微代理、事件总线、全局锁、决策竞选、分布式会话等等集成服务")]),r._v(" "),a("p",[r._v("SpringBoot可以离开SpringCloud独立使用开发项目， 但是SpringCloud离不开SpringBoot ，属于依赖的关系")]),r._v(" "),a("p",[r._v("SpringBoot专注于快速、方便的开发单个微服务个体，SpringCloud关注全局的服务治理框架。")]),r._v(" "),a("h1",{attrs:{id:"使用-spring-boot-开发分布式微服务时-我们面临以下问题"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#使用-spring-boot-开发分布式微服务时-我们面临以下问题"}},[r._v("#")]),r._v(" 使用 Spring Boot 开发分布式微服务时，我们面临以下问题")]),r._v(" "),a("ol",[a("li",[r._v("与分布式系统相关的复杂性-这种开销包括网络问题，延迟开销，带宽问题，安全问题。")]),r._v(" "),a("li",[a("strong",[r._v("服务发现-服务发现工具管理集群")]),r._v("中的流程和服务如何查找和互相交谈。它涉及一个服务目录，在该目录中注册服务，然后能够查找并连接到该目录中的服务。")]),r._v(" "),a("li",[r._v("冗余-分布式系统中的冗余问题。")]),r._v(" "),a("li",[a("strong",[r._v("负载平衡 --负载平衡改善跨多个计算资源的工作负荷")]),r._v("，诸如计算机，计算机集群，网络链路，中央处理单元，或磁盘驱动器的分布。")]),r._v(" "),a("li",[r._v("性能-问题 由于各种运营开销导致的性能问题。")]),r._v(" "),a("li",[r._v("部署复杂性-Devops 技能的要求。")])]),r._v(" "),a("h1",{attrs:{id:"spring-cloud-和dubbo区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring-cloud-和dubbo区别"}},[r._v("#")]),r._v(" Spring Cloud 和dubbo区别?")]),r._v(" "),a("ol",[a("li",[r._v("服务调用方式 dubbo是RPC springcloud Rest Api")]),r._v(" "),a("li",[r._v("注册中心,dubbo 是zookeeper springcloud是eureka，也可以是zookeeper")]),r._v(" "),a("li",[r._v("服务网关,dubbo本身没有实现，只能通过其他第三方技术整合，springcloud有Zuul路由网关，作为路由服务器，进行消费者的请求分发,springcloud支持断路器，与git完美集成配置文件支持版本控制，事物总线实现配置文件的更新与服务自动装配等等一系列的微服务架构要素。")])]),r._v(" "),a("h1",{attrs:{id:"eureka"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#eureka"}},[r._v("#")]),r._v(" Eureka")]),r._v(" "),a("h2",{attrs:{id:"服务注册和发现是什么意思-spring-cloud-如何实现"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务注册和发现是什么意思-spring-cloud-如何实现"}},[r._v("#")]),r._v(" 服务注册和发现是什么意思？Spring Cloud 如何实现？")]),r._v(" "),a("p",[r._v("当我们开始一个项目时，我们通常在属性文件中进行所有的配置。随着越来越多的服务开发和部署，添加和修改这些属性变得更加复杂。有些服务可能会下降，而某些位置可能会发生变化。手动更改属性可能会产生问题。 Eureka 服务注册和发现可以在这种情况下提供帮助。"),a("strong",[r._v("由于所有服务都在 Eureka 服务器上注册并通过调用 Eureka 服务器完成查找，因此无需处理服务地点的任何更改和处理")]),r._v("。")]),r._v(" "),a("h2",{attrs:{id:"什么是eureka"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是eureka"}},[r._v("#")]),r._v(" 什么是Eureka")]),r._v(" "),a("p",[r._v("Eureka作为SpringCloud的服务注册功能服务器，他是服务注册中心，系统中的其他服务使用Eureka的客户端将其连接到Eureka Service中，并且保持心跳，这样工作人员可以通过Eureka Service来监控各个微服务是否运行正常。")]),r._v(" "),a("h2",{attrs:{id:"eureka怎么实现高可用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#eureka怎么实现高可用"}},[r._v("#")]),r._v(" Eureka怎么实现高可用")]),r._v(" "),a("p",[r._v("集群吧，注册多台Eureka，然后把SpringCloud服务互相注册，客户端从Eureka获取信息时，按\n照Eureka的顺序来访问。")]),r._v(" "),a("h2",{attrs:{id:"eureka和zookeeper都可以提供服务注册与发现的功能-请说说两个的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#eureka和zookeeper都可以提供服务注册与发现的功能-请说说两个的区别"}},[r._v("#")]),r._v(" Eureka和ZooKeeper都可以提供服务注册与发现的功能,请说说两个的区别")]),r._v(" "),a("ol",[a("li",[r._v("ZooKeeper中的节点服务挂了就要选举 在选举期间注册服务瘫痪,虽然服务最终会恢复,但是选举期间不可用的， 选举就是改微服务做了集群，必须有一台主其他的都是从")]),r._v(" "),a("li",[r._v("Eureka各个节点是平等关系,服务器挂了没关系，只要有一台Eureka就可以保证服务可用，数据都是最新的。 如果查询到的数据并不是最新的，就是因为Eureka的自我保护模式导致的")]),r._v(" "),a("li",[r._v("Eureka本质上是一个工程,而ZooKeeper只是一个进程")]),r._v(" "),a("li",[r._v("Eureka可以很好的应对因网络故障导致部分节点失去联系的情况,而不会像ZooKeeper 一样使得整个注册系统瘫痪")]),r._v(" "),a("li",[r._v("ZooKeeper保证的是CP，Eureka保证的是AP\n"),a("code",[r._v("CAP： C：一致性>Consistency; 取舍：(强一致性、单调一致性、会话一致性、最终一致性、弱一致性) A：可用性>Availability; P：分区容错性>Partition tolerance;")])])]),r._v(" "),a("h1",{attrs:{id:"zuul"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zuul"}},[r._v("#")]),r._v(" Zuul")]),r._v(" "),a("h2",{attrs:{id:"什么是网关"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是网关"}},[r._v("#")]),r._v(" 什么是网关?")]),r._v(" "),a("p",[r._v("网关相当于一个网络服务架构的入口，所有网络请求必须通过网关转发到具体的服务。")]),r._v(" "),a("h2",{attrs:{id:"网关的作用是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网关的作用是什么"}},[r._v("#")]),r._v(" 网关的作用是什么")]),r._v(" "),a("p",[r._v("统一管理微服务请求，"),a("strong",[r._v("权限控制、负载均衡、路由转发、监控、安全控制黑名单和白名单")]),r._v("等")]),r._v(" "),a("h2",{attrs:{id:"网关与过滤器有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#网关与过滤器有什么区别"}},[r._v("#")]),r._v(" 网关与过滤器有什么区别")]),r._v(" "),a("p",[r._v("网关是对所有服务的请求进行分析过滤，过滤器是对单个服务而言。")]),r._v(" "),a("h2",{attrs:{id:"常用网关框架有那些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#常用网关框架有那些"}},[r._v("#")]),r._v(" 常用网关框架有那些？")]),r._v(" "),a("p",[r._v("Nginx、Zuul、Gateway")]),r._v(" "),a("h2",{attrs:{id:"zuul与nginx有什么区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#zuul与nginx有什么区别"}},[r._v("#")]),r._v(" Zuul与Nginx有什么区别？")]),r._v(" "),a("p",[r._v("Zuul是java语言实现的，主要为java服务提供网关服务，尤其在微服务架构中可以更加灵活的对网关进行操作。Nginx是使用C语言实现，性能高于Zuul，但是实现自定义操作需要熟悉lua语言，对程序员要求较高，可以使用Nginx做Zuul集群。")]),r._v(" "),a("h2",{attrs:{id:"既然nginx可以实现网关-为什么还需要使用zuul框架"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#既然nginx可以实现网关-为什么还需要使用zuul框架"}},[r._v("#")]),r._v(" 既然Nginx可以实现网关？为什么还需要使用Zuul框架")]),r._v(" "),a("p",[r._v("Zuul是SpringCloud集成的网关，使用Java语言编写，可以对SpringCloud架构提供更灵活的服务。")]),r._v(" "),a("h2",{attrs:{id:"如何设计一套api接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如何设计一套api接口"}},[r._v("#")]),r._v(" 如何设计一套API接口")]),r._v(" "),a("p",[r._v("考虑到API接口的分类可以将API接口分为开发API接口和内网API接口，内网API接口用于局域网，为内部服务器提供服务。开放API接口用于对外部合作单位提供接口调用，需要遵循Oauth2.0权限认证协议。同时还需要考虑安全性、幂等性等问题。")]),r._v(" "),a("h1",{attrs:{id:"ribbon"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ribbon"}},[r._v("#")]),r._v(" Ribbon")]),r._v(" "),a("h2",{attrs:{id:"负载平衡的意义什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#负载平衡的意义什么"}},[r._v("#")]),r._v(" 负载平衡的意义什么？")]),r._v(" "),a("p",[r._v("简单来说： 先将集群，集群就是把一个的事情交给多个人去做，假如要做1000个产品给一个人做要10天，我叫10个人做就是一天，这就是集群，负载均衡的话就是用来控制集群，他把做的最多的人让他慢慢做休息会，把做的最少的人让他加量让他做多点。在计算中，负载平衡可以改善跨计算机，计算机集群，网络链接，中央处理单元或磁盘驱动器等多种计算资源的工作负载分布。负载平衡旨在优化资源使用，最大化吞吐量，最小化响应时间并避免任何单一资源的过载。使用多个组件进行负载平衡而不是单个组件可能会通过冗余来提高可靠性和可用性。负载平衡通常涉及专用软件或硬件，例如多层交换机或域名系统服务器进程。")]),r._v(" "),a("h2",{attrs:{id:"ribbon是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ribbon是什么"}},[r._v("#")]),r._v(" Ribbon是什么？")]),r._v(" "),a("p",[r._v("Ribbon是Netflix发布的开源项目，主要功能是提供客户端的软件负载均衡算法Ribbon客户端组件提供一系列完善的配置项，如连接超时，重试等。简单的说，就是在配置文件中列出后面所有的机器，Ribbon会自动的帮助你基于某种规则（如简单轮询，随即连接等）去连接这些机器。我们也很容易使用Ribbon实现自定义的负载均衡算法。（有点类似Nginx）")]),r._v(" "),a("h2",{attrs:{id:"nginx与ribbon的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#nginx与ribbon的区别"}},[r._v("#")]),r._v(" Nginx与Ribbon的区别")]),r._v(" "),a("p",[r._v("Nginx是反向代理同时可以实现负载均衡，nginx拦截客户端请求采用负载均衡策略根据upstream配置进行转发，"),a("strong",[r._v("相当于请求通过nginx服务器进行转发。Ribbon是客户端负载均衡，从注册中心读取目标服务器信息，然后客户端采用轮询策略对服务直接访问，全程在客户端操作")]),r._v("。")]),r._v(" "),a("h2",{attrs:{id:"ribbon底层实现原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ribbon底层实现原理"}},[r._v("#")]),r._v(" Ribbon底层实现原理")]),r._v(" "),a("p",[r._v("Ribbon使用discoveryClient从注册中心读取目标服务信息，对同一接口请求进行计数，使用%取余算法获取目标服务集群索引，返回获取到的目标服务信息。")]),r._v(" "),a("h1",{attrs:{id:"hystrix"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hystrix"}},[r._v("#")]),r._v(" Hystrix")]),r._v(" "),a("h2",{attrs:{id:"什么是断路器"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是断路器"}},[r._v("#")]),r._v(" 什么是断路器")]),r._v(" "),a("ul",[a("li",[r._v("当一个服务调用另一个服务由于网络原因或自身原因出现问题，调用者就会等待被调用者的响应当更多的服务请求到这些资源导致更多的请求等待，发生连锁效应（雪崩效应）")]),r._v(" "),a("li",[r._v("断路器有三种状态")]),r._v(" "),a("li",[r._v("打开状态：一段时间内 达到一定的次数无法调用 并且多次监测没有恢复的迹象 断路器完全打开 那么下次请求就不会请求到该服务")]),r._v(" "),a("li",[r._v("半开状态：短时间内 有恢复迹象 断路器会将部分请求发给该服务，正常调用时 断路器关闭")]),r._v(" "),a("li",[r._v("关闭状态：当服务一直处于正常状态 能正常调用")])]),r._v(" "),a("h2",{attrs:{id:"什么是-hystrix"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-hystrix"}},[r._v("#")]),r._v(" 什么是 Hystrix？")]),r._v(" "),a("p",[r._v("在分布式系统，我们一定会依赖各种服务，那么这些个服务一定会出现失败的情况，就会导致雪崩，Hystrix就是这样的一个工具，防雪崩利器，它具有服务降级，服务熔断，服务隔离，监控等一些防止雪崩的技术。\nHystrix有四种防雪崩方式:\n服务降级：接口调用失败就调用本地的方法返回一个空\n服务熔断：接口调用失败就会进入调用接口提前定义好的一个熔断的方法，返回错误信息\n服务隔离：隔离服务之间相互影响\n服务监控：在服务发生调用时,会将每秒请求数、成功请求数等运行指标记录下来。")]),r._v(" "),a("h2",{attrs:{id:"谈谈服务雪崩效应"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#谈谈服务雪崩效应"}},[r._v("#")]),r._v(" 谈谈服务雪崩效应")]),r._v(" "),a("ul",[a("li",[a("p",[r._v("雪崩效应是在大型互联网项目中，当某个服务发生宕机时，调用这个服务的其他服务也会发生宕机，大型项目的微服务之间的调用是互通的，这样就会将服务的不可用逐步扩大到各个其他服务中，从而使整个项目的服务宕机崩溃.发生雪崩效应的原因有以下几点")])]),r._v(" "),a("li",[a("p",[r._v("单个服务的代码存在bug. 2请求访问量激增导致服务发生崩溃(如大型商城的枪红包，秒杀功能). 3.服务器的硬件故障也会导致部分服务不可用.")])]),r._v(" "),a("li",[a("p",[r._v("因为Tomcat默认情况下只有一个线程池来维护客户端发送的所有的请求，这时候某一接口在某一时刻被大量访问就会占据tomcat线程池中的所有线程，其他请求处于等待状态，无法连接到服务接口。")])])]),r._v(" "),a("h2",{attrs:{id:"服务降级底层是如何实现的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#服务降级底层是如何实现的"}},[r._v("#")]),r._v(" 服务降级底层是如何实现的？")]),r._v(" "),a("p",[r._v("Hystrix实现服务降级的功能是通过重写HystrixCommand中的getFallback()方法，当Hystrix的run方法或construct执行发生错误时转而执行getFallback()方法。")]),r._v(" "),a("h1",{attrs:{id:"feign"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#feign"}},[r._v("#")]),r._v(" Feign")]),r._v(" "),a("h2",{attrs:{id:"什么是feign"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是feign"}},[r._v("#")]),r._v(" 什么是Feign？")]),r._v(" "),a("p",[r._v("Feign 是一个声明web服务客户端，这使得编写web服务客户端更容易他将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。")]),r._v(" "),a("h2",{attrs:{id:"springcloud有几种调用接口方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#springcloud有几种调用接口方式"}},[r._v("#")]),r._v(" SpringCloud有几种调用接口方式")]),r._v(" "),a("ul",[a("li",[r._v("Feign")]),r._v(" "),a("li",[r._v("RestTemplate")])]),r._v(" "),a("h2",{attrs:{id:"ribbon和feign调用服务的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ribbon和feign调用服务的区别"}},[r._v("#")]),r._v(" Ribbon和Feign调用服务的区别")]),r._v(" "),a("p",[r._v("调用方式同：Ribbon需要我们自己构建Http请求，模拟Http请求然后通过RestTemplate发给其他服务，步骤相当繁琐\n而Feign则是在Ribbon的基础上进行了一次改进，采用接口的形式，将我们需要调用的服务方法定义成抽象方法保存在本地就可以了，不需要自己构建Http请求了，直接调用接口就行了，不过要注意，调用方法要和本地抽象方法的签名完全一致。")]),r._v(" "),a("h1",{attrs:{id:"bus"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#bus"}},[r._v("#")]),r._v(" Bus")]),r._v(" "),a("h2",{attrs:{id:"什么是-spring-cloud-bus-我们需要它吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是-spring-cloud-bus-我们需要它吗"}},[r._v("#")]),r._v(" 什么是 Spring Cloud Bus？我们需要它吗？")]),r._v(" "),a("p",[r._v("考虑以下情况：我们有多个应用程序使用 Spring Cloud Config 读取属性，而Spring Cloud Config 从 GIT 读取这些属性。")]),r._v(" "),a("p",[r._v("如果假设 GIT 中的 Eureka 注册属性更改为指向另一台 Eureka 服务器，会发生什么情况。在这种情况下，我们将不得不重新启动服务以获取更新的属性。")]),r._v(" "),a("p",[r._v("还有另一种使用执行器端点/刷新的方式。但是我们将不得不为每个模块单独调用这个 url。例如，如果 Employee Producer1 部署在端口 8080 上，则调用 http：// localhost：8080 / refresh。同样对于 Employee Producer2 http：//localhost：8081 / refresh 等等。这又很麻烦。这就是 Spring Cloud Bus 发挥作用的地方。")]),r._v(" "),a("p",[r._v("Spring Cloud Bus 提供了跨多个实例刷新配置的功能。因此，在上面的示例中，如果我们刷新 Employee Producer1，则会自动刷新所有其他必需的模块。如果我们有多个微服务启动并运行，这特别有用。这是通过将所有微服务连接到单个消息代理来实现的。无论何时刷新实例，此事件都会订阅到侦听此代理的所有微服务，并且它们也会刷新。可以通过使用端点/总线/刷新来实现对任何单个实例的刷新。")]),r._v(" "),a("h1",{attrs:{id:"config"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#config"}},[r._v("#")]),r._v(" Config")]),r._v(" "),a("h2",{attrs:{id:"什么是spring-cloud-config"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是spring-cloud-config"}},[r._v("#")]),r._v(" 什么是Spring Cloud Config?")]),r._v(" "),a("p",[r._v("在分布式系统中，由于服务数量巨多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件spring cloud config ，它支持配置服务放在配置服务的内存中（即本地），也支持放在远程Git仓库中。在spring cloud config 组件中，分两个角色，一是config server，二是config client。")]),r._v(" "),a("p",[r._v("使用：")]),r._v(" "),a("ul",[a("li",[r._v("添加pom依赖")]),r._v(" "),a("li",[r._v("配置文件添加相关配置")]),r._v(" "),a("li",[r._v("启动类添加注解@EnableConfigServer")])]),r._v(" "),a("h1",{attrs:{id:"gateway"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#gateway"}},[r._v("#")]),r._v(" Gateway")]),r._v(" "),a("h2",{attrs:{id:"什么是spring-cloud-gateway"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是spring-cloud-gateway"}},[r._v("#")]),r._v(" 什么是Spring Cloud Gateway?")]),r._v(" "),a("p",[r._v("Spring Cloud Gateway是Spring Cloud官方推出的第二代网关框架，取代Zuul网关。网关作为流量的，在微服务系统中有着非常作用，网关常见的功能有路由转发、权限校验、限流控制等作用。")]),r._v(" "),a("p",[r._v("使用了一个RouteLocatorBuilder的bean去创建路由，除了创建路由RouteLocatorBuilder可以让你添加各种predicates和filters，predicates断言的意思，顾名思义就是根据具体的请求的规则，由具体的route去处理，filters是各种过滤器，用来对请求做各种判断和修改。")])])}),[],!1,null,null,null);t.default=s.exports}}]);