(window.webpackJsonp=window.webpackJsonp||[]).push([[103],{541:function(t,n,a){"use strict";a.r(n);var e=a(16),r=function(t){t.options.__data__block__={markmap_1a962850:'## JDK\n- 数据类型\n\t- 整数 `byte、short、int、long`\n\t- 浮点 `float、double`\n\t- 字符 `char`\n\t- 布尔 `boolean`\n- 引用类型\n\t- 类 `class`\n\t- 接口 `interface`\n\t- 数组 `[]`\n- String\n\t- 不变性\n\t- 常量区优化\n\t- final\n- 修饰符 `public 公共，protected 受保护，default 默认，private 私有`\n- 运算符\n\t- & `按位与、逻辑与`\n\t- && `短路运算`\n- 关键字 \n\t- final\n\t\t- 类不可以被继承\n\t\t- 方法不可以被重写\n\t\t- 变量不可以被改变\n\t- this\n\t- super\n\t- static\n\t\t- 成员变量\n\t\t- 成员方法\n\t\t- 代码块\n\t\t- 内部类\n- 重写与重载\n- == 和 equals 的区别\n\t- **hashCode()** `获取哈希码`\n\t- equals 方法被覆盖过，则 hashCode 方法也必须被覆盖\n- 值传递\n- 反射 `动态获取的信息以及动态调用对象`\n\t- 获取\n\t\t- `stu.getClass();`\n\t\t- `Class.forName("fanshe.Student");`\n\t\t- `Student.class;`\n\t- 使用\n\t\t- JDBC连接数据库\n\t\t- Spring框架\n\t\t\t- 配置文件加载入内存\n\t\t\t- 字符串获得某个类的Class实例',markmap_382ee145:"## 数据结构\n- 数据结构\n\t- 线性表(ArrayList))\n\t- 链表（LinkdList）\n\t- 栈（Stack） 先进后出\n\t- 队列(Quote)\n\t- 图（Map）\n\t- 树（Tree）\n- 集合\n\t- List `有序、可重复`\n\t\t- ArrayList\n\t\t\t- 底层是数组\n\t\t\t- 索引数据结构\n\t\t\t- 随机访问快\n\t\t\t- 插入或删除慢\n\t\t\t\t- 数据间没有间隔\n\t\t\t\t- 需要移动元素\n\t\t- LinkedList\n\t\t\t- 双向链表\n\t\t\t- 更占内存\n\t\t\t- 添加和删除快\n\t\t\t- 随机访问慢\n\t\t- Vector `线程安全`\n\t\t\t- 性能慢\n\t\t- CopyOnWriteArrayList `线程安全`\n\t- Set `无序、不可重复`\n\t\t- HashSet\n\t\t\t- 底层是HashMap\n\t\t\t- LinkHashSet\n\t\t- TreeSet `二叉树`\n\t\t\t- 按照指定的顺序排序\n\t- Map\n\t\t- HashMap\n\t\t\t- 结构\n\t\t\t\t- 链表+数组\n\t\t\t\t- 红黑树（java8）\n\t\t\t- key可以为null\n\t\t\t- 线程不安全\n\t\t\t- 效率高 `hash算法`\n\t\t\t- 容量\n\t\t\t\t- 初始容量16\n\t\t\t\t- 扩容因子0.75\n\t\t\t\t\t- 和哈希表的重建有关\n\t\t\t\t- 容量2倍`数据分配均匀`\n\t\t- Hashtable\n\t\t\t- 线程安全\n\t\t\t\t- 使用了synchronized，全表锁\n\t\t\t- 性能低下\n\t\t- ConcurrentHashMap\n\t\t\t- 线程安全\n\t\t\t\t- 1.7 使用了分段锁(Segment数组)，性能好\n\t\t\t\t- 1.8 Node + CAS + Synchronized来保证并发安全，性能更好\n\t\t\t\t- 并行度16\n\t\t- TreeMap `有序的key-value集合`\n\t\t\t- 基于红黑树实现\n\t\t- Hashcode（hash算法）`映射为固定长度的较小的二进制值`\n\t\t\t- 提升查找元素的效率\n\t\t\t\t- 若干存储区域\n\t\t\t\t- 对象计算出哈希码\n\t\t\t\t\t- 对象的内存地址值计算的序号\n\t\t\t\t\t- 高16bit不变，低16bit和高16bit做了一个异或、减少碰撞\n\t\t\t\t- 映射哈希码范围到对应的区域\n\t\t\t\t\t- 冲突则放入链表",markmap_382ee149:"## 并发编程\n* 并发编程优缺点\n\t- 为什么要使用并发编程（优点）\n\t- 并发编程三要素 `安全性问题``\n\t\t- 原子性\n\t\t- 可见性\n\t\t- 有序性\n\t- 并发编程遇到的问题\n\t\t- 内存泄漏\n\t\t- 上下文切换\n\t\t- 线程安全\n\t\t- 死锁\n- 并行和并发\n\t- 并发：`同一个CPU核心，多个任务交替执行`\n\t- 并行：`多核处理器同时处理多个任务`\n- 线程和进程\n\t- 进程：`一个内存中运行的任务程序`\n\t- 线程：`进程中的一个执行任务`\n\t- 同步锁 `同一时间内只允许一个线程访问共享数据`\n\t- 线程死锁\n\t\t- 四个条件\n\t\t\t- 互斥条件\n\t\t\t- 请求与保持条件\n\t\t\t- 不剥夺条件\n\t\t\t- 循环等待条件\n\t\t- 避免死锁：`破坏四个条件中的一个`\n- 创建线程的方法\n\t- 继承 Thread 类\n\t- 实现 Runnable 接口\n\t- 实现 Callable 接口 `可以使用Future获取返回值`\n\t\t- 重写run()\n\t\t- 调用start() `启动线程`\n\t- 使用 Executors 工具类创建线程池\n- 线程的状态\n\t- 新建\n\t- 可运行\n\t- 运行\n\t- 阻塞\n\t\t- 等待阻塞：wait()\n\t\t- 同步阻塞：synchronized \n\t\t- 其他阻塞：sleep()或 join()、IO\n\t- 死亡(dead)\n- 线程的调度\n\t- wait() `使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁;`\n\t- sleep()：`使一个正在运行的线程处于睡眠状态；`\n\t- notify()：`唤醒一个处于等待状态的线程\n\t- notityAll()：`唤醒所有处于等待状态的线程`\n\t- 保证线程安全 `多个线程访问同一代码，不会产生不确定的结果`\n\t- volatile变量修饰符\n\t\t- 禁止指令重排序\n\t\t- 仅能实现变量的修改可见性，不能保证原子性，确保写操作发生在读操作之前\n\t\t- 安全类：如原子类AtomicInteger\n- 几种锁\n\t- 自动锁：synchronized\n\t\t- 使用场景\n\t\t\t- 修饰实例方法\n\t\t\t- 修饰静态方法\n\t\t\t- 修饰代码块`效率更高`\n\t- ReentrantLock（重入锁） `使用起来比较灵活，但是必须有释放锁的配合动作`\n\t- ReentrantReadWriteLock（读写锁）\n\t- 手动锁：Lock\n\t\t- Lock是个Java类\n\t\t- 需要自己加锁和释放锁\n\t\t- 乐观锁和悲观锁\n\t\t\t- 拿数据的时候认为别人是否会修改\n- 并发容器\n\t- ConcurrentHashMap \n\t\t- 线程安全且高效的HashMap实现\n\t\t- 锁分段的思想提高了并发度\n\t- Vector `性能差`\n\t- HashTable\n\t- ThreadLocal`线程局部变量`\n\t\t- 手动调用remove()方法 `避免内存泄漏`\n\t- BlockingQueue`阻塞队列`\n\t- CopyOnWriteArrayList\n- Executors 线程池\n\t- 池化技术`减少对象创建和销毁的耗时`\n\t\t- 线程池\n\t\t- 数据库连接池\n\t\t- Http连接池\n\t- 快速创建`不推荐`\n\t\t- newSingleThreadExecutor`单线程的线程池`\n\t\t- newFixedThreadPool`固定大小的线程池`\n\t\t- newScheduledThreadPool`无限大小的线程池`\n\t- 优点\n\t\t- 降低资源消耗\n\t\t- 提升响应速度\n\t\t- 提高线程的可管理性\n\t- ThreadPoolExecutor**推荐**\n\t\t- 定义参数\n\t\t\t- corePoolSize 核心线程数\n\t\t\t- maximumPoolSize 最大线程数\n\t\t\t- keepAliveTime 线程销毁时间\n\t\t\t- workQueue 任务队列\n\t\t- submit() 提交\n\t\t- Future  异步计算的结果\n\t\t- 饱和策略\n\t\t\t- 抛出异常ThreadPoolExecutor.AbortPolicy：`抛出 RejectedExecutionException`\n\t\t\t- 新起线程\n\t\t\t- 丢弃\n\t- 如何合理分配线程池大小\n\t\t- CPU密集\n\t\t- IO密集",markmap_382ee165:"## JVM\n* 运行机制\n\t- 编写.java\n\t- 编译字节码.class\n\t- 运行字节码\n- 运行时数据区\n\t- 线程私有\n\t\t- 程序计数器`字节码运行`\n\t\t- Java虚拟机栈`局部变量表、操作数栈、动态链接`\n\t\t- 本地方法栈\n\t- 线程共享\n\t\t- Java堆`对象实例`\n\t\t- 方法区`类信息、常量、静态变量、编译后的代码`\n- 堆和栈的区别\n\t- 物理地址分配\n\t- 内存大小\n\t- 存放内容\n\t- 可见度 `是否线程共享`\n- 内存泄露\n\t- 内存没有被GC自动回收\n- 深拷贝和浅拷贝\n- 垃圾回收\n\t- 垃圾回收机制的优缺点\n\t\t- 自动回收\n\t\t- 不可预知\n\t- 回收机制算法\n\t\t- 分代复制垃圾回收\n\t\t\t- 新生代`一般站堆的1/3空间`\n\t\t\t\t- YGC\n\t\t\t- 老年代 `声明周期长的对象`\n\t\t\t\t- FGC\n\t\t\t- 永久代`永久区域，不会被清理`\n\t\t- 标记垃圾回收\n\t\t\t- 标记无用对象\n\t\t- 增量垃圾回收\n\t\t- 复制算法\n\t- 回收判定方法\n\t\t- 引用计数器\n\t\t- 可达性分析\n- 类加载机制\n\t- 显式加载 `class.forname()`\n\t- 隐式加载 `new`\n- 类加载过程\n\t- 加载`按路径导入class`\n\t- 验证`检查class文件正确性`\n\t- 准备`给静态变量分配内存空间`\n\t- 解析`替换引用的常量`\n\t- 初始化`初始化静态变量和静态代码块`\n- JVM调优\n\t- 工具\n\t\t- jconsole\n\t\t- jvisualvm\n\t\t- jprofiler `分析工具`\n\t\t- Memory Analyzer Tool `dump分析工具`\n\t- JVM调优参数\n\t\t- 堆大小\n\t\t- 新生代大小\n\t\t- 垃圾回收器",markmap_382ee169:"* File类\n\t- 文件流 `基于文件的操作`\n\t\t- FileInputStream：字节输入流\n\t\t- FileOutputStream：字节输出流\n\t\t- FileReader：字符输入流\n\t\t- FileWriter：字符输出流\n\t- 缓冲流`对读写的数据提供了缓冲的功能，提高了读写的效率`\n\t\t- BufferedInputStream：缓冲字节输入流\n\t\t- BufferedOutputStream：缓冲字节输出流\n\t\t- BufferedReader：缓冲字符输入流\n\t\t- BufferedWriter：缓冲字符输出流\n\t- 转换流`对字符编码进行转换`\n\t\t- InputStreamReader：转换字节输入流为字符输入流\n\t\t- OutputStreamReader：转换字节输出流为字符输出流\n\t- 打印流"}},s=Object(e.a)({},(function(){var t=this,n=t.$createElement,a=t._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"java进阶思维导图"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java进阶思维导图"}},[t._v("#")]),t._v(" Java进阶思维导图")]),t._v(" "),a("h2",{attrs:{id:"jdk"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jdk"}},[t._v("#")]),t._v(" JDK")]),t._v(" "),a("Markmap",{attrs:{id:"markmap_1a962850",code:t.$dataBlock.markmap_1a962850}}),a("h2",{attrs:{id:"数据结构"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#数据结构"}},[t._v("#")]),t._v(" 数据结构")]),t._v(" "),a("Markmap",{attrs:{id:"markmap_382ee145",code:t.$dataBlock.markmap_382ee145}}),a("h2",{attrs:{id:"并发编程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#并发编程"}},[t._v("#")]),t._v(" 并发编程")]),t._v(" "),a("Markmap",{attrs:{id:"markmap_382ee149",code:t.$dataBlock.markmap_382ee149}}),a("h2",{attrs:{id:"jvm"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#jvm"}},[t._v("#")]),t._v(" JVM")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s2.loli.net/2022/06/22/5hceFHwbiMt3Var.png",alt:"image-20211122072146563"}})]),t._v(" "),a("Markmap",{attrs:{id:"markmap_382ee165",code:t.$dataBlock.markmap_382ee165}}),a("h2",{attrs:{id:"io流"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#io流"}},[t._v("#")]),t._v(" IO流")]),t._v(" "),a("Markmap",{attrs:{id:"markmap_382ee169",code:t.$dataBlock.markmap_382ee169}})],1)}),[],!1,null,null,null);"function"==typeof r&&r(s);n.default=s.exports}}]);