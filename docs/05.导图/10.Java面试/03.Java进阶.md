---
title: Java进阶
article: false
pageClass: custom-page-class
date: 2021-11-11 15:42:30
permalink: /mind/7af745/
---

# Java进阶思维导图

## 并发编程
```markmap
## 并发编程
* 并发编程优缺点
	- 为什么要使用并发编程（优点）
	- 并发编程有什么缺点
	- 并发编程三要素
		- 原子性
		- 可见性
		- 有序性
- 并行和并发
	- 并发：`同一个CPU核心，多个任务交替执行`
	- 并行：`多核处理器同时处理多个任务`
- 线程和进程
	- 进程：`一个内存中运行得任务程序`
	- 线程：`进程中的一个执行任务`
	- 线程死锁
		- 四个条件
			- 互斥条件
			- 请求与保持条件
			- 不剥夺条件
			- 循环等待条件
		- 避免死锁：`破坏四个条件中的一个`
- 创建线程的方法
	- 继承 Thread 类
	- 实现 Runnable 接口`可以使用Future获取返回值`
	- 实现 Callable 接口
	- 使用 Executors 工具类创建线程池
- 线程的状态
	- 新建
	- 可运行
	- 运行
	- 阻塞
		- 等待阻塞：wait()
		- 同步阻塞：synchronized 
		- 其他阻塞：sleep()或 join()、IO
	- 死亡(dead)
- 线程的调度
	- wait() `使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁;`
	- sleep()：`使一个正在运行的线程处于睡眠状态；`
	- notify()：`唤醒一个处于等待状态的线程
	- notityAll()：`唤醒所有处于等待状态的线程`
- 保证线程安全
	- volatile变量修饰符
		- 禁止指令重排序
		- 仅能实现变量的修改可见性，不能保证原子性，确保写操作发生在读操作之前
		- 安全类：如原子类AtomicInteger
	- 自动锁：synchronized
		- 使用场景
			- 修饰实例方法
			- 修饰静态方法
			- 修饰代码块`效率更高`
		- synchronized可重入
	- ReentrantLock（重入锁） `使用起来比较灵活，但是必须有释放锁的配合动作`
	- ReentrantReadWriteLock（读写锁）
	- 手动锁：Lock
		- Lock是个Java类
		- 需要自己加锁和释放锁
		- 乐观锁和悲观锁
- 并发容器
	- ConcurrentHashMap 
		- 线程安全且高效的HashMap实现
		- 锁分段的思想提高了并发度
	- Vector
	- HashTable
	- ThreadLocal`线程局部变量`
		- 手动调用remove()方法
	- BlockingQueue`阻塞队列`
- Executors 线程池
	- 池化技术`减少对象创建和销毁的耗时`
		- 线程池
		- 数据库连接池
		- Http连接池
	- 快速创建`不推荐`
		- newSingleThreadExecutor`单线程的线程池`
		- newFixedThreadPool`固定大小的线程池`
		- newScheduledThreadPool`无限大小的线程池`
	- 优点
		- 降低资源消耗
		- 提升响应速度
		- 提高线程的可管理性
	- ThreadPoolExecutor**推荐**
		- 定义参数
			- corePoolSize 核心线程数
			- maximumPoolSize 最大线程数
			- keepAliveTime 线程销毁时间
			- workQueue 任务队列
		- submit() 提交
		- Future  异步计算的结果
		- 饱和策略
			- 抛出异常ThreadPoolExecutor.AbortPolicy：`抛出 RejectedExecutionException`
			- 新起线程
			- 丢弃
```

## Java异常

```markmap
## Java异常
* 异常架构
	- Throwable
		- Error`无法处理的错误`
			- 系统崩溃
			- OutOfMemoryError（内存不足）
			- StackOverflowError（堆栈溢出）
		- Exception`可以捕获的异常`
			- RuntimeException`运行时异常`
				- ClassCastException(类转换异常)
				- IndexOutOfBoundsException(数组越界)
			- RuntimeException以外`编译时异常`
				- NumberFormatException
- 异常关键字
	- try 
	- catch
	- finally
	- throw `抛出异常`
	- throws `异常声明`
- 异常处理
	- 声明异常
	- 抛出异常
	- 捕获异常
- try-with-resource`Java 7`
	- 实现AutoCloseable接口
```

## JVM
```markmap
## JVM
* 运行机制
	- 编写.java
	- 编译字节码.class
	- 运行字节码
- 运行时数据区
	- 程序计数器`字节码运行`
	- Java虚拟机栈`局部变量表、操作数栈、动态链接`
	- 本地方法栈
	- Java堆`对象实例`
	- 方法区`类信息、常量、静态变量、编译后的代码`
- 堆和栈的区别
	- 物理地址分配
	- 内存大小
	- 存放内容
	- 可见度
- 内存泄露
	- 内存没有被GC自动回收
- 深拷贝和浅拷贝
- 垃圾回收
	- 垃圾回收机制的优点
	- 回收机制算法
		- 分代复制垃圾回收
			- 新生代
			- 老年代
		- 标记垃圾回收
			- 标记无用对象
		- 增量垃圾回收
	- 回收判定方法
		- 引用计数器
		- 可达性分析
- 类加载机制
	- 显式加载 `class.forname()`
	- 隐式加载 `new`
- 类加载过程
	- 加载`按路径导入class`
	- 验证`检查class文件正确性`
	- 准备`给静态变量分配内存空间`
	- 解析`替换引用的常量`
	- 初始化`初始化静态变量和静态代码块`
- JVM调优
	- 工具
		- jconsole
		- jprofiler
	- JVM调优参数
```
## IO流
```markmap
* File类
	- 文件流 `基于文件的操作`
		- FileInputStream：字节输入流
		- FileOutputStream：字节输出流
		- FileReader：字符输入流
		- FileWriter：字符输出流
	- 缓冲流`对读写的数据提供了缓冲的功能，提高了读写的效率`
		- BufferedInputStream：缓冲字节输入流
		- BufferedOutputStream：缓冲字节输出流
		- BufferedReader：缓冲字符输入流
		- BufferedWriter：缓冲字符输出流
	- 转换流`对字符编码进行转换`
		- InputStreamReader：转换字节输入流为字符输入流
		- OutputStreamReader：转换字节输出流为字符输出流
	- 打印流
```