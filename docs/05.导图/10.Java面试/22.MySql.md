---
title: Mysql
article: false
date: 2021-11-11 18:55:16
pageClass: custom-page-class
permalink: /pages/7f3642/
---
# Mysql

```markmap
# Mysql 
* `开源的关系型数据库管理系统`
* 表设计
    - 三大范式
        - 每个列不可拆分
        - 非主键完全依赖逐渐
        - 非主键之依赖主键，不能依赖其他非主键
- 存储引擎（Storage engine）
    - nnodb引擎（默认）
        - 数据库ACID事务的支持
        - 聚簇索引
        - 主键索引非常高效
        - 并发量高和事务
    - MyIASM引擎(原本Mysql的默认引擎)
        - 非聚簇索引
        - 适合读写为主
    - MEMORY引擎：所有的数据都在内存中
- 索引
    - 优点
        - 加快数据检索
        - 优化隐藏器
    - 缺点
        - 创建和维护索引需要时间，降低更新效率
        - 索引占用物理空间
    - **创建索引的原则**
        - 最左匹配，向右匹配到范围查询
        - 频繁查询的字段
        - 频繁更新的字段不适合
        - 外键的数据列一定要创建索引
        - 类型数据量大的不要创建索引
    - 使用场景
        - where
        - order by
            - 所有数据从磁盘读取到内存进行排序很耗时
        - join
            - 对连接字段建立索引提升效率
        - like
            - 会使索引失效
    - 类型
        - 主键索引
            - 不能为null
            - 只能有一个主键
        - 唯一索引
            - 数据不允许重复
        - 普通索引
        - 全文索引
    - **数据结构**
        - B+树索引（=,>,>=,<,<=和between）
            - 原理
                - 最常见的索引
                - 叶子结点保存了关键字信息和指针
                - 非叶子节点都是索引部分
                - 数据的插入和删除在叶子节点进行
            - 特点
                - 稳定性该，查询速度快
        - B树
            - 内部节点可以同时存储键和值
        - 哈希索引（=）
            - 原理
                - Hash算法
                - 字段数据转换成定长的Hash值
            - 特点
                - hash索引等值查询更快
                - 无法进行范围索引
                - 不支持排序
    - 使用方式
        - CREATE TABLE
            - KEY
        - ALTER TABLE
            - ADD INDEX
        - CREATE INDEX
        - drop primary key
- 数据类型
    - 整数
        - tinyInt
        - smallint
        - mediumint
        - int(integer)
    - 小数
        - float
        - double
        - decimal(m,d) 效率低一点
    - 日期
        - year
        - time
        - date
        - datetime
        - timestamp 推荐
    - 文本、二进制
        - CHAR(M) 效率高
        - VARCHAR(M)
        - TINYBLOB
        - BLOB 额外性能开销
        - ....
        - TEXT
- 数据库事务
    - ACID
        - 原子性
        - 一致性
        - 隔离性
        - 持久性
    - 隔离级别
        - READ-UNCOMMITTED(读取未提交) 脏读
        - REPEATABLE-READ(可重复读) 幻读，不可重复度
        - READ-COMMITTED(读取已提交) 不可重复读
        - SERIALIZABLE(可串行化)
- 锁
    - 类型
        - 行级锁(INNODB引擎)
            - 只针对当前操作的行进行加锁
            - 开销大，加锁慢
            - 锁冲突的概率最低
            - 并发度高
        - 表级锁(MYISAM引擎)
            - 开销小，加锁快
            - 发出锁冲突的概率最高
            - 并发度最低
        - 页级锁(BDB引擎 )
            - 开销和加锁时间界于表锁和行锁之间
    - 死锁`多个事务在同一资源上相互占用，并请求锁定对方的资源`
        - 乐观锁`多读`
        - 悲观锁`多写`
    - SQL语句
        - 分类
            - DDL
            - DQL
            - DML
            - DCL
        - 连接查询
            - 内连接
            - 外连接
                - 左外
                - 右外
            - 交叉连接
        - 子查询
        - 关键字语句
            - in 小表
            - exits 大表
            - limit
            - rowNum
    - SQL优化
        - 执行计划`explan`
            - 查看是否使用索引
            - 访问类型
                - ALL 扫描全表
                - index 遍历索引
        - 大表数据量查询
            - 优化schema、sql语句+索引
            - 加缓存 memcached, redis
            - 主从复制、读写菲尼
            - 垂直拆分
            - 水平拆分（分表）
        - 优化查询
            - 访问数据太多导致查询性能下降
            * 确定应用程序是否在检索大量超过需要的数据，可能是太多行或列
            * 确认MySQL服务器是否在分析大量不必要的数据行
            * 避免犯如下SQL语句错误
            * 查询不需要的数据。解决办法：使用limit解决
            * 多表关联返回全部列。解决办法：指定列名
            * 总是返回全部列。解决办法：避免使用SELECT *
            * 重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存
            * 是否在扫描额外的记录。解决办法：
            * 使用explain进行分析，如果发现查询需要扫描大量的数据，但只返回少数的行，可以通过如下技巧去优化：
            * 使用索引覆盖扫描，把所有的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。
            * 改变数据库和表的结构，修改数据表范式
            * 重写SQL语句，让优化器可以以更优的方式执行查询。
```